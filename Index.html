<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Geminus - Aetherial Shard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://css.gg/css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc, collection, addDoc, query, orderBy, limitToLast, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Make Firebase functions globally available
        window.firebase = {
            initializeApp,
            getAuth,
            signInAnonymously,
            getFirestore,
            doc,
            setDoc,
            getDoc,
            updateDoc,
            collection,
            addDoc,
            query,
            orderBy,
            limitToLast,
            onSnapshot,
            serverTimestamp
        };
    </script>

    <style>
        /* --- Base & Typography (Theme-Independent) --- */
        html, body {    
            height: 100%;    
            overflow: hidden;    
        }
        body {    
            font-family: 'Inter', sans-serif;    
            background-color: #121212;
            -webkit-user-select: none;    
            user-select: none;    
            touch-action: manipulation;
            transition: background-color 0.5s;
        }
        .font-orbitron {    
            font-family: 'Orbitron', sans-serif;    
        }

        /* --- Animated Background --- */
        #smoke-canvas {    
            position: fixed;    
            top: 0; left: 0;    
            width: 100%; height: 100%;    
            z-index: -1;    
            pointer-events: none;    
            opacity: 0.5;    
        }

        /* --- AETHERIAL SHARD THEME (CYAN) --- */
        body.theme-aetherial-shard {
            --highlight-color: #22d3ee;
            --highlight-color-rgb: 34, 211, 238;
            --glow-color: #67e8f9;
            --text-primary: #f0f0f0;
            --text-secondary: #a0a0a0;
            --panel-bg-color: rgba(30, 35, 45, 0.65);
            --input-bg: rgba(0, 0, 0, 0.4);
            --border-color-main: rgba(34, 211, 238, 0.4);
            --border-color-pulse: rgba(103, 232, 249, 0.7);
            --hp-color: #22c55e;
            --name-color: var(--highlight-color);
            --gold-color: #facc15;
            --destroy-color: #f87171;
            --glow-caster: #3b82f6;
            --glow-fighter: #ef4444;
            --glow-misc: #22c55e;
            --glow-full: #ef4444;
            --glow-partial: #3b82f6;
        }

        @keyframes pulse-border-cyan {
            0%, 100% { border-color: var(--border-color-main); box-shadow: 0 0 15px rgba(34, 211, 238, 0.2), 0 4px 30px rgba(0, 0, 0, 0.6); }
            50% { border-color: var(--border-color-pulse); box-shadow: 0 0 25px rgba(103, 232, 249, 0.3), 0 4px 30px rgba(0, 0, 0, 0.6); }
        }
        @keyframes pulse-main-tab-glow-cyan {
            0%, 100% { border-bottom-color: var(--highlight-color); text-shadow: 0 0 8px var(--highlight-color); }
            50% { border-bottom-color: var(--glow-color); text-shadow: 0 0 12px var(--glow-color); }
        }

        body.theme-aetherial-shard .glass-panel { animation-name: pulse-border-cyan; }
        body.theme-aetherial-shard .main-tab-button.active { animation-name: pulse-main-tab-glow-cyan; }
        body.theme-aetherial-shard .glass-panel {
            background-image: linear-gradient(var(--panel-bg-color), var(--panel-bg-color)),
                            url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='4' height='4' viewBox='0 0 4 4'%3E%3Cpath fill='%23ffffff' fill-opacity='0.02' d='M1 3h1v1H1V3zm2-2h1v1H3V1z'%3E%3C/path%3E%3C/svg%3E");
        }
        body.theme-aetherial-shard .gem-item.selected { border-color: var(--glow-color); box-shadow: 0 0 10px var(--glow-color); }

        /* --- MOLTEN CORE THEME (ORANGE/RED) --- */
        body.theme-molten-core {
            --highlight-color: #f97316;
            --highlight-color-rgb: 249, 115, 22;
            --glow-color: #ef4444;
            --text-primary: #f0f0f0;
            --text-secondary: #a0a0a0;
            --panel-bg-color: rgba(20, 20, 22, 0.85);
            --input-bg: rgba(0, 0, 0, 0.4);
            --border-color-main: rgba(249, 115, 22, 0.4);
            --border-color-pulse: rgba(239, 68, 68, 0.7);
            --hp-color: #E53935;
            --name-color: var(--highlight-color);
            --gold-color: #facc15;
            --destroy-color: #f87171;
            --glow-caster: #3b82f6;
            --glow-fighter: #ef4444;
            --glow-misc: #22c55e;
            --glow-full: #ef4444;
            --glow-partial: #3b82f6;
        }

        @keyframes pulse-border-molten {
            0%, 100% { border-color: var(--border-color-main); box-shadow: 0 0 15px rgba(249, 115, 22, 0.2), 0 4px 30px rgba(0, 0, 0, 0.6); }
            50% { border-color: var(--border-color-pulse); box-shadow: 0 0 25px rgba(239, 68, 68, 0.4), 0 4px 30px rgba(0, 0, 0, 0.6); }
        }
        @keyframes pulse-main-tab-glow-molten {
            0%, 100% { border-bottom-color: var(--highlight-color); text-shadow: 0 0 8px var(--highlight-color); }
            50% { border-bottom-color: var(--glow-color); text-shadow: 0 0 12px var(--glow-color); }
        }
        
        body.theme-molten-core .glass-panel { animation-name: pulse-border-molten; }
        body.theme-molten-core .main-tab-button.active { animation-name: pulse-main-tab-glow-molten; }
        body.theme-molten-core .glass-panel { background: var(--panel-bg-color); }
        body.theme-molten-core .gem-item.selected { border-color: var(--glow-color); box-shadow: 0 0 10px var(--glow-color); }


        /* --- Core UI Components (Theme-Dependent Styles) --- */
        body { color: var(--text-primary); }
        
        /* Text Glow Styles */
        .text-glow-label {
            color: var(--highlight-color);
            font-weight: 700;
            text-shadow: 0 0 8px var(--highlight-color);
        }
        .text-glow-subtle {
            color: var(--text-primary);
            text-shadow: 0 0 5px var(--highlight-color);
        }

        .glass-panel {
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border: 1px solid;
            animation-duration: 4s;
            animation-timing-function: ease-in-out;
            animation-iteration-count: infinite;
        }
        .glass-button {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color-main);
            color: var(--text-primary);
            transition: all 0.2s ease-in-out;
            display: flex; align-items: center; justify-content: center; flex-shrink: 0;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 5px var(--highlight-color);
        }
        .glass-button:not(:disabled):hover, .glass-button.active {
            background: rgba(var(--highlight-color-rgb), 0.15);
            border-color: var(--highlight-color);
            transform: translateY(-2px);
            color: var(--highlight-color);
            text-shadow: 0 0 10px var(--highlight-color);
        }
        .glass-button:disabled {
            background: rgba(60, 60, 60, 0.4) !important;    
            border-color: rgba(100, 100, 100, 0.8) !important;
            cursor: not-allowed;    
            color: #6b7280 !important;    
            text-shadow: none !important;    
            box-shadow: none !important;    
            animation: none;
        }
        .glass-button:not(:disabled):active { transform: translateY(1px) scale(0.98); }
        
        /* --- Scrollbars & Progress Bars --- */
        .progress-bar-track { background-color: rgba(0,0,0,0.5); border-radius: 9999px; overflow: hidden; border: 1px solid rgba(0,0,0,0.7); }
        .progress-bar-fill { border-radius: 9999px; height: 100%; transition: width 0.3s ease-out; }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background-color: var(--border-color-main); border-radius: 3px; }
        .custom-scrollbar-x::-webkit-scrollbar { height: 4px; }
        .custom-scrollbar-x::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar-x::-webkit-scrollbar-thumb { background-color: var(--border-color-main); border-radius: 2px; }

        /* --- Main Layout & Tabs --- */
        #main-content { transition: transform 0.4s ease-in-out, opacity 0.4s ease-in-out; }
        #main-content.focused { position: fixed; inset: 0; z-index: 50; width: 100vw; height: 100vh; border-radius: 0; padding: 0; }
        .main-tab-button {
            flex-shrink: 0; font-family: 'Orbitron', sans-serif; font-size: 0.8rem;
            padding: 0.75rem 1rem; background: transparent; border: none;
            border-bottom: 3px solid transparent; color: var(--text-secondary);
            cursor: pointer; transition: color 0.3s;
        }
        .main-tab-button.active {
            color: var(--highlight-color);
            animation-duration: 4s;
            animation-timing-function: ease-in-out;
            animation-iteration-count: infinite;
        }
        .main-tab-panel { display: none; }
        .main-tab-panel.active { display: block; }

        /* --- Modals & Toasts --- */
        .modal-backdrop {position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 60; padding: 1rem; }
        #toast-notification { position: fixed; bottom: -100px; left: 50%; transform: translateX(-50%); padding: 12px 24px; border-radius: 8px; font-weight: 600; transition: bottom 0.5s ease-in-out; z-index: 100; border: 1px solid; }
        .toast-error { background-color: rgba(255, 80, 80, 0.2); border-color: #ff5050; color: #ff5050; }
        .toast-success { background-color: rgba(var(--highlight-color-rgb), 0.2); border-color: var(--highlight-color); color: var(--highlight-color); }
        @keyframes flash { 0% { color: #fff; text-shadow: 0 0 10px #fff; } 50% { color: var(--highlight-color); text-shadow: 0 0 15px var(--highlight-color); } 100% { color: #fff; text-shadow: none; } }
        .flash-update { animation: flash 0.5s ease-out; }
        #stat-info-modal { position: fixed; inset: 0; z-index: 1001; background-color: rgba(0,0,0,0.7); display: none; align-items: center; justify-content: center; }
        #stat-info-backdrop { position: absolute; inset: 0; }
        .stat-info-content { background: var(--panel-bg-color); border: 1px solid var(--border-color-main); padding: 1.5rem; border-radius: 0.5rem; max-width: 300px; text-align: center; }
        #item-action-modal-backdrop { position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.6); z-index: 998; display: none; }
        #item-action-modal-content { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 999; width: 90%; max-width: 320px; display: none; }
        .item-action-modal-body { text-align: center; }
        .item-action-modal-body .item-name { font-family: 'Orbitron', sans-serif; font-size: 1.25rem; margin-bottom: 0.25rem; }
        .item-action-modal-body .item-type { font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 0.75rem; }
        .item-action-modal-body .item-stat { font-size: 1rem; margin-bottom: 0.75rem; }
        .item-action-modal-body .item-stat-label { color: var(--text-secondary); }
        .item-action-modal-body .item-stat-value { font-weight: 600; color: var(--text-primary); }

        /* --- Chat UI --- */
        .footer-tab-button.active { color: var(--highlight-color); font-weight: bold; }
        .footer-chat-input { background: var(--input-bg); border: 1px solid var(--border-color-main); color: var(--text-primary); }
        .footer-chat-input::placeholder { color: var(--text-secondary); }
        .footer-chat-input:focus {outline: none; border-color: var(--highlight-color); }
        .sidebar-closed { transform: translateX(-100%); }
        .sidebar-open { transform: translateX(0); }
        .chat-bubble { background: rgba(10, 15, 20, 0.7) !important; -webkit-backdrop-filter: blur(10px); backdrop-filter: blur(10px); border: 1px solid; position: relative; }
        .chat-bubble-user { border-color: var(--border-color-main); }
        .chat-bubble-other { border-color: rgba(var(--highlight-color-rgb), 0.2); }
        .reply-icon { cursor: pointer; opacity: 0.4; transition: opacity 0.2s; }
        .message-wrapper:hover .reply-icon { opacity: 1; }
        .reply-quote { background: rgba(0,0,0,0.3); border-left: 2px solid var(--highlight-color); padding: 6px 10px; border-radius: 4px; margin-bottom: 8px; font-size: 0.8rem; }
        .avatar { width: 40px; height: 40px; border-radius: 50%; object-fit: cover; border: 2px solid var(--border-color-main); }
        .btn-primary { background-color: transparent; border: 2px solid var(--highlight-color); color: var(--highlight-color); transition: all 0.3s ease; }
        .btn-primary:hover { background-color: var(--highlight-color); color: #000; box-shadow: 0 0 15px var(--highlight-color); }
        #chat-modal .tab { cursor: pointer; transition: all 0.2s; border-bottom: 3px solid transparent; padding-bottom: 8px; color: var(--text-secondary); }
        #chat-modal .tab.active { color: var(--highlight-color); border-bottom-color: var(--highlight-color); animation-name: pulse-main-tab-glow-cyan; animation-duration: 4s; animation-iteration-count: infinite; }
        body.theme-molten-core #chat-modal .tab.active { animation-name: pulse-main-tab-glow-molten; }
        #chat-modal input, #modal-container input { background: var(--input-bg); border: 1px solid var(--border-color-main); border-radius: 0.5rem; padding: 0.75rem 1rem; transition: all 0.2s; color: var(--text-primary); }
        #chat-modal input::placeholder, #modal-container input::placeholder { color: var(--text-secondary); }
        #chat-modal input:focus, #modal-container input:focus {outline: none; border-color: var(--highlight-color); box-shadow: 0 0 10px rgba(var(--highlight-color-rgb), 0.4); }

        /* --- Stats Accordion Styles --- */
        .stat-accordion-item { background: rgba(0,0,0,0.2); border-radius: 0.5rem; margin-bottom: 0.75rem; overflow: hidden; border: 1px solid rgba(var(--highlight-color-rgb), 0.15); }
        .stat-accordion-header { display: flex; justify-content: space-between; align-items: center; width: 100%; padding: 0.75rem 1rem; background: rgba(var(--highlight-color-rgb), 0.05); cursor: pointer; border: none; text-align: left; }
        .stat-accordion-header h3 { font-family: 'Orbitron', serif; font-size: 1.1rem; }
        .accordion-arrow { transition: transform 0.3s ease; color: var(--text-secondary); }
        .stat-accordion-item.open .accordion-arrow { transform: rotate(90deg); }
        .stat-accordion-content { max-height: 0; overflow: hidden; transition: max-height 0.4s ease-out, padding 0.4s ease-out; padding: 0 1rem; }
        .stat-accordion-item.open .stat-accordion-content { max-height: 1000px; padding: 1rem; }
        .stat-line { display: flex; align-items: center; padding: 0.5rem 0; font-size: 0.9rem; border-bottom: 1px solid rgba(var(--highlight-color-rgb), 0.1); }
        .stat-line:last-child { border-bottom: none; }
        .stat-line .stat-name { flex-grow: 1; }
        .info-btn { background: none; border: 1px solid var(--text-secondary); color: var(--text-secondary); border-radius: 50%; width: 20px; height: 20px; font-size: 0.7rem; line-height: 18px; text-align: center; cursor: pointer; margin-left: 0.75rem; transition: all 0.2s; }
        .info-btn:hover { background-color: var(--highlight-color); border-color: var(--highlight-color); color: black; }
        .attr-btn { background: rgba(var(--highlight-color-rgb), 0.2); border: 1px solid var(--border-color-main); color: var(--highlight-color); border-radius: 6px; width: 28px; height: 28px; font-weight: bold; cursor: pointer; transition: all 0.2s; margin-left: 0.5rem; font-size: 1.2rem; }
        .attr-btn:hover:not(:disabled) { background: rgba(var(--highlight-color-rgb), 0.4); }
        .attr-btn:disabled { background: rgba(75, 85, 99, 0.2); border-color: #4b5563; color: #6b7280; cursor: not-allowed; }

        /* --- Inventory & Gem Grid Styles --- */
        .inventory-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(72px, 1fr)); gap: 0.75rem; }
        .inventory-slot { position: relative; width: 100%; padding-bottom: 100%; height: 0; border: 1px solid var(--border-color-main); border-radius: 0.375rem; background: rgba(0,0,0,0.4); cursor: pointer; transition: all 0.2s; }
        .inventory-slot:hover { border-color: var(--highlight-color); transform: translateY(-2px); }
        .inventory-slot img { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain; padding: 8px; }
        .item-label { position: absolute; bottom: 2px; right: 2px; background: rgba(0,0,0,0.7); font-size: 0.6rem; padding: 1px 3px; border-radius: 3px; }
        .gem-pouch-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(64px, 1fr)); gap: 0.5rem; }
        .gem-item { position: relative; border: 2px solid; border-radius: 0.375rem; background: rgba(0,0,0,0.2); cursor: pointer; aspect-ratio: 1 / 1; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
        .gem-item:hover { transform: scale(1.1); }
        .gem-item.selected-for-socket { box-shadow: 0 0 12px var(--glow-color); transform: scale(1.1); }
        .gem-item .item-label { position: absolute; bottom: 2px; right: 2px; background: rgba(0,0,0,0.7); font-size: 0.6rem; padding: 1px 3px; border-radius: 3px; color: var(--text-primary); }
        .editor-input { background-color: rgba(0,0,0,0.3); border: 1px solid var(--border-color-main); color: var(--text-primary); padding: 6px 10px; border-radius: 6px; width: 100%; font-size: 14px; transition: all 0.2s ease; }
        .editor-input:focus { outline: none; border-color: var(--highlight-color); box-shadow: 0 0 8px var(--highlight-color); }

        /* --- NEW Gem Overlay System --- */
        .gem-overlays-container {
            position: absolute;
            top: 4px;
            left: 4px;
            right: 4px;
            height: auto;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }
        .gem-overlay {
            padding: 1px 4px;
            font-size: 0.65rem;
            font-weight: bold;
            color: white;
            border-radius: 4px;
            text-shadow: 1px 1px 2px black;
            border: 1px solid rgba(0,0,0,0.5);
        }
        .gem-overlay.fighter { background-color: var(--glow-fighter); }
        .gem-overlay.caster { background-color: var(--glow-caster); }
        .gem-overlay.misc { background-color: var(--glow-misc); }
        .item-tier-label { position: absolute; bottom: 4px; right: 4px; background: var(--gold-color); font-size: 0.7rem; font-weight: bold; padding: 1px 5px; border-radius: 4px; color: #1f2937; }


        /* --- Equipment Grid Styles --- */
        .equipment-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; }
        .equipment-slot-wrapper { background-color: transparent; border-radius: 0.5rem; padding: 0.5rem; border: 2px solid transparent; }
        .equipment-slot-title { display: flex; align-items: center; gap: 0.5rem; font-weight: 600; color: var(--text-primary); margin-bottom: 0.5rem; font-size: 0.8rem; }
        .equipment-slot-content { display: flex; align-items: center; justify-content: center; gap: 0.5rem; border-radius: 0.375rem; min-height: 60px; padding: 4px; position: relative; background-color: rgba(0,0,0,0.2); cursor:pointer; border: 1px solid transparent; transition: all 0.2s; }
        .equipment-slot-content:hover { border-color: var(--highlight-color); }
        
        /* --- Infusion & Socketing Styles (FIXED & SCOPED) --- */
        #infusion-container .tab-panel { display: none; }
        #infusion-container .tab-panel.active { display: block; }
        #infusion-container .modal-content { position: relative; width: 90%; max-width: 480px; display: none; z-index: 999; }
        #infusion-container .modal-button { flex: 1; padding: 0.75rem 0.5rem; font-size: 0.9rem; font-family: 'Orbitron', sans-serif; border: 1px solid var(--border-color-main); border-radius: 0.375rem; background: rgba(0,0,0,0.4); color: var(--text-primary); transition: all 0.2s ease; }
        #infusion-container .modal-button:hover { background: rgba(var(--highlight-color-rgb), 0.2); border-color: var(--highlight-color); }
        #infusion-container .modal-button.confirm { border-color: var(--glow-color); color: var(--glow-color); }
        #infusion-container .modal-button.confirm:hover { background: rgba(103, 232, 249, 0.2); }
        #infusion-container .modal-button.destroy { border-color: var(--destroy-color); color: var(--destroy-color); }
        #infusion-container .modal-button.destroy:hover { background: rgba(248, 113, 113, 0.2); }
        #info-modal-content .modal-body { max-height: 60vh; overflow-y: auto; padding-right: 1rem; }
        #infusion-container .pouch-background { background-color: rgba(0,0,0,0.4); background-image: url("data:image/svg+xml,%3Csvg width='6' height='6' viewBox='0 0 6 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23222' fill-opacity='0.3' fill-rule='evenodd'%3E%3Cpath d='M5 0h1L0 6V5zM6 5v1H5z'/%3E%3C/g%3E%3C/svg%3E"); border: 1px solid rgba(0,0,0,0.5); box-shadow: inset 0 0 25px rgba(0,0,0,0.6); border-radius: 0.25rem; padding: 1rem; }
        #infusion-container .item-glow-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 0.375rem; pointer-events: none; transition: box-shadow 0.3s ease-in-out; }
        #infusion-container .glow-partial { box-shadow: 0 0 12px 3px var(--glow-partial); }
        #infusion-container .glow-full { box-shadow: 0 0 12px 3px var(--glow-full); }
        #infusion-container .filter-bar { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 1rem; }
        #infusion-container .filter-btn { padding: 0.3rem 0.8rem; border: 1px solid var(--border-color-main); border-radius: 6px; background: transparent; color: var(--text-secondary); font-size: 0.8rem; transition: all 0.2s ease; }
        #infusion-container .filter-btn.active, #infusion-container .filter-btn:hover { background: rgba(var(--highlight-color-rgb), 0.2); color: var(--highlight-color); border-color: var(--highlight-color); }
        #infusion-container .filter-group { display: flex; flex-wrap: wrap; gap: 0.5rem; }
        #infusion-container .gem-item.gem-type-Fighter { border-color: var(--glow-fighter); }
        #infusion-container .gem-item.gem-type-Caster { border-color: var(--glow-caster); }
        #infusion-container .gem-item.gem-type-Misc { border-color: var(--glow-misc); }
        #infusion-container .tab-bar { display: flex; border-bottom: 1px solid var(--border-color-main); }
        #infusion-container .tab-button { flex: 1; padding: 0.75rem 0.5rem; font-family: 'Orbitron', sans-serif; border: none; background: transparent; color: var(--text-secondary); border-bottom: 3px solid transparent; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; gap: 0.5rem; }
        #infusion-container .primary-tab-button { font-size: 1rem; }
        #infusion-container .secondary-tab-button { font-size: 0.9rem; padding: 0.5rem; border-bottom-width: 2px; }
        #infusion-container .tab-button.active { color: var(--highlight-color); border-bottom-color: var(--highlight-color); font-weight: 700; text-shadow: 0 0 8px var(--highlight-color); }


        /* --- HUD & Mini-Map Styles --- */
        #player-status-container .info-label { margin-right: 0.5rem; }
        #player-status-container .name-value { color: var(--name-color); font-weight: bold; }
        #mini-map-panel { width: 120px; height: 120px; }
        #mini-map-container { width: 100%; height: 100%; position: relative; }
        #mini-map-canvas { width: 100%; height: 100%; }
        #toggle-controls-btn { position: absolute; right: 8px; bottom: 8px; z-index: 10; }
        
        /* --- Combat UI --- */
        #combat-stats-container { display: grid; grid-template-columns: auto 1fr auto 1fr; gap: 0.1rem 1rem; font-size: 0.75rem; }
        .log-player { color: #84cc16; } /* lime-500 */
        .log-enemy { color: #ef4444; font-weight: bold; } /* red-500 */
        .log-system { color: var(--text-secondary); }
        .log-gold { color: #eab308; } /* yellow-500 */
        .log-xp { color: #38bdf8; } /* sky-400 */
        .log-loot-item { color: #a855f7; } /* purple-500 */
        .log-loot-gem { color: var(--highlight-color); }

        /* --- D-Pad and Interaction Key Styles --- */
        .game-key { display: flex; align-items: center; justify-content: center; font-family: 'Orbitron', sans-serif; font-weight: 900; color: var(--highlight-color); background: var(--panel-bg-color); border: 2px solid var(--border-color-main); border-radius: 8px; cursor: pointer; user-select: none; transition: all 0.1s ease-in-out; text-shadow: 0 0 8px var(--highlight-color); }
        .move-key { width: 50px; height: 50px; font-size: 24px; }
        .move-key svg { width: 1.2em; height: 1.2em; fill: currentColor; }
        #d-pad-controls { display: grid; grid-template-areas: ". up ." "left down right"; gap: 10px; }
        #key-up { grid-area: up; } #key-left { grid-area: left; } #key-down { grid-area: down; } #key-right { grid-area: right; }
        #key-interact { width: 170px; height: 50px; font-size: 18px; font-weight: 700; margin-top: 10px; }
        .game-key.pressed { background: rgba(10, 10, 12, 0.85); border-color: var(--glow-color); transform: scale(0.95); box-shadow: 0 0 15px var(--glow-color), 0 0 20px rgba(0,0,0,0.6) inset; color: var(--glow-color); }

        /* --- Footer Controls Toggle --- */
        #footer-section { transition: all 0.4s ease-in-out; }
        #communication-panel { flex-grow: 1; transition: all 0.4s ease-in-out; }
        #controls-panel { flex-shrink: 0; transition: all 0.4s ease-in-out; transform-origin: right; }
        #footer-section.controls-hidden #controls-panel { max-width: 0px; opacity: 0; transform: scaleX(0.5); padding: 0; margin: 0; border: none; overflow: hidden; }
        
        /* --- Layout Edit Mode Styles --- */
        .layout-edit-mode .tappable-section,
        .layout-edit-mode .tappable-tab { cursor: pointer; border: 2px dashed var(--highlight-color) !important; animation: none !important; transition: transform 0.2s, box-shadow 0.2s; }
        .layout-selected { border: 2px solid var(--glow-color) !important; box-shadow: 0 0 15px var(--glow-color) !important; transform: scale(1.02); }
    </style>
</head>
<body class="bg-black text-gray-200">

    <canvas id="smoke-canvas"></canvas>

    <div id="game-container" class="h-full">
        
        <div id="game-hud-screen" class="relative z-10 h-full hidden">
            <div id="layout-container" class="max-w-md mx-auto h-full flex flex-col p-2 gap-2">

                <div id="hud-container" class="tappable-section" data-order="1">
                    <header id="hud-section" class="relative glass-panel p-3 rounded-lg flex justify-between items-center flex-shrink-0 gap-2">
                        <section id="player-status-panel" class="flex-1">
                            <div id="player-status-container" class="flex flex-col space-y-1">
                                <p class="font-orbitron text-base name-value text-glow-label" id="player-name-level-value">Player Lvl: 1</p>
                                <p class="text-xs"><span class="info-label text-glow-label">Race:</span><span class="info-value text-glow-subtle" id="player-race-value"></span></p>
                                <p class="text-xs"><span class="info-label text-glow-label">A-Spec:</span><span class="info-value text-glow-subtle" id="player-aspec-value"></span></p>
                                <p class="text-xs"><span class="info-label text-glow-label">Zone:</span><span class="info-value text-glow-subtle" id="zone-name-value"></span></p>
                                <p class="text-xs text-glow-label" id="player-coords-value">(0,0)</p>
                            </div>
                        </section>
                        <section id="mini-map-panel" class="mr-12">
                            <div id="mini-map-container">
                                <div class="absolute -inset-1 rounded-full border border-dashed border-orange-500/30 animate-spin" style="animation-duration: 20s; animation-timing-function: linear;"></div>
                                <div class="relative w-full h-full rounded-full overflow-hidden glass-panel border-2 border-[var(--border-color-main)]">
                                    <canvas id="mini-map-canvas"></canvas>
                                </div>
                            </div>
                        </section>
                        <button id="toggle-controls-btn" class="glass-button w-11 h-11 rounded-full text-2xl !p-0">🎮</button>
                    </header>
                </div>

                <div id="main-content-container" class="tappable-section flex-grow flex flex-col overflow-hidden" data-order="2">
                    <section id="main-content-panel" class="flex-grow flex flex-col overflow-hidden">
                        <main id="main-content" class="flex-grow flex flex-col overflow-hidden glass-panel rounded-lg relative">
                            <button id="focus-mode-btn" class="absolute bottom-2 right-2 w-8 h-8 rounded-full bg-red-600 border border-white/30 flex items-center justify-center cursor-pointer transition-colors hover:bg-red-500 z-50" title="Toggle Focus Mode">
                                <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5v-4m0 0h-4m4 0l-5-5"></path></svg>
                            </button>
                            <button id="layout-edit-btn" class="absolute bottom-2 left-2 w-8 h-8 rounded-full bg-blue-600 border border-white/30 flex items-center justify-center cursor-pointer transition-colors hover:bg-blue-500 z-50" title="Toggle Layout Edit Mode">
                                <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                            </button>
                            <div id="main-tabs-container" class="flex-shrink-0 flex items-center overflow-x-auto whitespace-nowrap custom-scrollbar-x border-b" style="border-color: var(--border-color-main);">
                                <button class="main-tab-button active tappable-tab" data-tab="equipment" data-tab-order="1">Equipment</button>
                                <button class="main-tab-button tappable-tab" data-tab="infusion" data-tab-order="2">Infusion</button>
                                <button class="main-tab-button tappable-tab" data-tab="inventory" data-tab-order="3">Inventory</button>
                                <button class="main-tab-button tappable-tab" data-tab="stats" data-tab-order="4">Stats</button>
                                <button class="main-tab-button tappable-tab" data-tab="combat" data-tab-order="5">Combat</button>
                                <button class="main-tab-button tappable-tab" data-tab="settings" data-tab-order="6">Settings</button>
                            </div>
                            <div id="main-tab-content" class="flex-grow p-2 md:p-4 overflow-y-auto custom-scrollbar relative">
                                <div id="tab-content-equipment" class="main-tab-panel active"></div>
                                <div id="tab-content-infusion" class="main-tab-panel">
                                    <!-- INFUSION HTML CONTENT (FIXED) -->
                                    <div id="infusion-container">
                                        <div class="flex justify-between items-center mb-2">
                                            <h2 class="text-xl font-orbitron text-glow-label">Infusion</h2>
                                            <button id="info-button" class="filter-btn">Info/how to 🙋‍♂️🙋‍♀️</button>
                                        </div>
                                        <div class="glass-panel rounded-lg p-1 sm:p-2">
                                            <div class="tab-bar">
                                                <button class="tab-button primary-tab-button active" data-tab="socket"><i class="gg-plug"></i> Socket</button>
                                                <button class="tab-button primary-tab-button" data-tab="unsocket"><i class="gg-unplug"></i> Unsocket</button>
                                            </div>
                                            <div class="p-2 sm:p-4">
                                                <div id="infusion-socket-panel" class="tab-panel primary-panel active">
                                                    <div class="tab-bar mb-4">
                                                        <button class="tab-button secondary-tab-button active" data-view="visual">Visual View</button>
                                                        <button class="tab-button secondary-tab-button" data-view="text">Text View</button>
                                                    </div>
                                                    <div id="socket-visual-view" class="tab-panel secondary-panel active">
                                                        <div class="grid md:grid-cols-2 gap-4">
                                                            <div>
                                                                <h3 class="text-lg font-orbitron mb-3 text-glow-label"><i class="gg-box mr-2"></i>Gems</h3>
                                                                <div class="pouch-background">
                                                                    <div id="gem-type-filter-bar" class="filter-group mb-3"></div>
                                                                    <div id="gem-grade-filter-bar" class="filter-group mb-3"></div>
                                                                    <div id="infusion-gem-pouch-grid" class="gem-pouch-grid"></div>
                                                                </div>
                                                            </div>
                                                            <div>
                                                                <h3 class="text-lg font-orbitron mb-3 text-glow-label"><i class="gg-anvil mr-2"></i>Items</h3>
                                                                <div class="pouch-background">
                                                                    <div id="item-filter-bar-socket" class="flex flex-col gap-3"></div>
                                                                    <div id="item-inventory-grid-socket" class="inventory-grid mt-4"></div>
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                    <div id="socket-text-view" class="tab-panel secondary-panel">
                                                        <div class="pouch-background space-y-4">
                                                            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
                                                                <div class="md:col-span-1">
                                                                    <label for="text-item-select" class="text-sm text-gray-400">Items</label>
                                                                    <select id="text-item-select" class="editor-input"></select>
                                                                </div>
                                                                <div class="md:col-span-1">
                                                                    <label for="text-gem-select" class="text-sm text-gray-400">Gems</label>
                                                                    <select id="text-gem-select" class="editor-input"></select>
                                                                </div>
                                                                <button id="text-socket-btn" class="modal-button confirm">Socket Gem</button>
                                                            </div>
                                                            <hr class="border-t border-gray-600">
                                                            <div>
                                                                <h4 class="font-orbitron text-lg mb-2 text-glow-label">Socketed Items</h4>
                                                                <div id="text-socketed-items-display" class="text-sm font-mono space-y-1 text-gray-300"></div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                                <div id="infusion-unsocket-panel" class="tab-panel primary-panel">
                                                    <h3 class="text-lg font-orbitron mb-3 text-glow-label"><i class="gg-anvil mr-2"></i>Items with Gems</h3>
                                                    <div class="pouch-background">
                                                        <div id="item-filter-bar-unsocket" class="flex flex-col gap-3"></div>
                                                        <div id="item-inventory-grid-unsocket" class="inventory-grid mt-4"></div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div id="tab-content-inventory" class="main-tab-panel"></div>
                                <div id="tab-content-stats" class="main-tab-panel"></div>
                                <div id="tab-content-combat" class="main-tab-panel">
                                    <!-- COMBAT HTML CONTENT (FIXED) -->
                                    <div class="space-y-4 flex flex-col h-full">
                                        <div id="combat-info-panel" class="w-full p-2 rounded-lg bg-black/20 border" style="border-color: var(--border-color-main)">
                                            <div id="combat-stats-container"></div>
                                        </div>
                                        <div class="combat-control-bar flex gap-2 p-2 bg-black/20 rounded-lg">
                                            <select id="monsterSelect" class="editor-input flex-grow"></select>
                                            <button class="glass-button px-4 py-2" id="fightBtn">FIGHT</button>
                                        </div>
                                        <div class="flex justify-center gap-2">
                                            <button class="glass-button py-2 rounded-md w-1/2" id="attackBtn" style="display: none;">ATTACK</button>
                                            <button class="glass-button py-2 rounded-md w-1/2" id="castBtn" style="display: none;">CAST</button>
                                            <button class="glass-button py-2 rounded-md w-1/2" id="spellstrikeBtn" style="display: none;">SPELLSTRIKE</button>
                                        </div>
                                        <div id="combat-log-display" class="flex-grow p-2 text-center text-sm"></div>
                                    </div>
                                </div>
                                <div id="tab-content-settings" class="main-tab-panel"></div>
                            </div>
                        </main>
                    </section>
                </div>

                <div id="footer-container" class="tappable-section" data-order="3">
                    <footer id="footer-section" class="flex-shrink-0 flex items-stretch gap-2 controls-hidden">
                        <section id="communication-panel" class="flex-grow">
                            <div id="footer-chat-container" class="h-full glass-panel w-full p-2 rounded-lg flex flex-col">
                                <div class="flex-shrink-0 flex flex-wrap gap-1 mb-2">
                                    <button data-channel="main" class="footer-tab-button glass-button text-xs px-3 py-1 rounded-md flex-grow active">Main</button>
                                    <button data-channel="sales" class="footer-tab-button glass-button text-xs px-3 py-1 rounded-md flex-grow">Sales</button>
                                    <button data-channel="clan" class="footer-tab-button glass-button text-xs px-3 py-1 rounded-md flex-grow">Clan</button>
                                    <button id="open-chat-modal-btn" class="glass-button text-xs px-2 py-1 rounded-md" title="Open Full Chat">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5v-4m0 0h-4m4 0l-5-5"></path></svg>
                                    </button>
                                </div>
                                <div id="footer-chat-content-wrapper" class="text-xs space-y-1 overflow-y-auto custom-scrollbar" style="height: 70px;"></div>
                                <form id="footer-message-form" class="flex-shrink-0 flex gap-2 mt-2">
                                    <input type="text" id="footer-message-input" class="footer-chat-input flex-grow w-full px-2 py-1 text-xs rounded-md" placeholder="Type a message..." autocomplete="off">
                                    <button type="submit" id="footer-send-button" class="glass-button text-xs px-3 py-1 rounded-md">Send</button>
                                </form>
                            </div>
                        </section>
                        <section id="controls-panel" class="h-full glass-panel p-2 rounded-lg">
                            <div class="flex flex-col items-center justify-center h-full">
                                <div id="d-pad-controls">
                                    <div class="game-key move-key" id="key-up" data-key="up"><svg viewBox="0 0 24 24"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path></svg></div>
                                    <div class="game-key move-key" id="key-left" data-key="left"><svg viewBox="0 0 24 24"><path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"></path></svg></div>
                                    <div class="game-key move-key" id="key-down" data-key="down"><svg viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z"></path></svg></div>
                                    <div class="game-key move-key" id="key-right" data-key="right"><svg viewBox="0 0 24 24"><path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"></path></svg></div>
                                </div>
                                <div class="game-key" id="key-interact" data-key="interact">Interact</div>
                            </div>
                        </section>
                    </footer>
                </div>
            </div>
        </div>
    </div>

    <!-- MODAL CONTAINER: This is where modals will be injected by JS -->
    <div id="modal-container"></div>
    <div id="toast-notification"></div>

    <!-- CHAT MODAL -->
    <div id="chat-modal" class="modal-backdrop hidden">
        <div class="relative w-11/12 max-w-5xl h-[90vh] max-h-[850px] rounded-2xl flex glass-panel overflow-hidden">
            <button id="close-chat-modal-btn" class="absolute top-3 right-4 text-gray-400 hover:text-white z-50">
                <svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
            <div id="sidebar-overlay" class="fixed inset-0 bg-black/60 z-30 hidden md:hidden"></div>
            <div id="sidebar" class="absolute md:relative z-40 h-full w-4/5 max-w-xs md:w-1/3 md:max-w-[320px] flex flex-col p-4 transition-transform duration-300 ease-in-out sidebar-closed md:sidebar-open glass-panel md:bg-transparent md:border-r md:border-l-0 md:border-t-0 md:border-b-0 md:shadow-none" style="border-color: rgba(255,255,255,0.1);">
                <button id="close-sidebar-btn" class="md:hidden absolute top-4 right-4 text-gray-300 hover:text-white"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button>
                <div class="mt-8 md:mt-0 p-3 glass-panel rounded-lg">
                    <div class="flex items-center gap-3">
                        <img id="sidebar-avatar" src="https://placehold.co/64x64/1e232d/22d3ee?text=J" class="avatar w-12 h-12">
                        <div class="text-left overflow-hidden">
                            <p id="sidebar-username" class="font-bold text-lg truncate font-orbitron">JuugBoyTV</p>
                            <p class="text-xs capitalize" style="opacity: 0.8;">Player</p>
                        </div>
                    </div>
                </div>
                <div class="flex-grow flex flex-col min-h-0 pt-4">
                    <h2 id="online-users-header" class="text-lg font-orbitron mb-2 pl-2">Online</h2>
                    <div id="online-users-list" class="flex-grow overflow-y-auto custom-scrollbar pr-2"></div>
                </div>
            </div>
            <div class="flex-1 flex flex-col w-full md:w-auto min-w-0">
                <div class="p-4 border-b flex items-center justify-between relative bg-black/20" style="border-color: rgba(255,255,255,0.1);">
                    <button id="open-sidebar-btn" class="md:hidden"><svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg></button>
                    <div id="tabs-container" class="flex-grow flex justify-center gap-4 md:gap-8 text-md font-orbitron font-bold">
                        <div class="tab active" data-channel="main">Main Chat</div>
                        <div class="tab" data-channel="sales">Sales Chat</div>
                        <div class="tab" data-channel="clan">Clan Chat</div>
                    </div>
                    <div class="w-7 md:hidden"></div>
                </div>
                <div id="content-container" class="flex-grow flex flex-col min-h-0 bg-black/10">
                    <div id="chat-messages" class="flex-grow p-4 overflow-y-auto custom-scrollbar"></div>
                </div>
                <div id="typing-indicator" class="px-4 pb-2 text-sm text-gray-500 h-6"></div>
                <div id="reply-indicator" class="px-4 pt-2 hidden"><div class="glass-panel bg-opacity-80 rounded-t-lg p-2 text-sm"><div class="flex justify-between items-center"><div><p class="font-semibold" style="color: var(--highlight-color);">Replying to <span id="reply-username"></span></p><p id="reply-text" class="text-gray-300 truncate"></p></div><button id="cancel-reply-btn" class="text-gray-400 hover:text-white text-2xl">&times;</button></div></div></div>
                <form id="message-form" class="p-4 flex items-center gap-3 border-t bg-black/20" style="border-color: rgba(255,255,255,0.1);">
                    <input type="text" id="message-input" placeholder="Type your message..." autocomplete="off" class="flex-grow">
                    <button type="submit" id="send-button" class="font-bold py-3 px-5 rounded-lg btn-primary">Send</button>
                </form>
            </div>
        </div>
    </div>
    
    <!-- ITEM ACTION MODAL AND OTHER HIDDEN ELEMENTS -->
    <div id="item-action-modal-backdrop" style="display: none;"></div>
    <div id="item-action-modal-content" class="glass-panel p-4 rounded-lg" style="display: none;">
        <div id="item-action-modal-body" class="item-action-modal-body"></div>
    </div>
    <div id="stat-info-modal" style="display: none;">
        <div id="stat-info-backdrop"></div>
        <div class="stat-info-content glass-panel">
            <h4 id="stat-info-title" class="font-orbitron text-lg text-white mb-2"></h4>
            <p id="stat-info-description" class="text-gray-300"></p>
        </div>
    </div>
    <div id="info-modal-backdrop" class="modal-backdrop" style="display: none;">
        <div id="info-modal-content" class="modal-content glass-panel p-6 rounded-lg"></div>
    </div>
    <div id="gem-tooltip-backdrop" class="modal-backdrop" style="display: none;">
        <div id="gem-tooltip-content" class="modal-content glass-panel p-4 rounded-lg"></div>
    </div>
    <div id="socket-confirm-backdrop" class="modal-backdrop" style="display: none;">
        <div id="socket-confirm-content" class="modal-content glass-panel p-4 rounded-lg"></div>
    </div>
    <div id="unsocket-choice-modal-backdrop" class="modal-backdrop" style="display: none;">
        <div id="unsocket-choice-modal-content" class="modal-content glass-panel p-4 rounded-lg"></div>
    </div>

    <script type="module">
        // --- App State & Config
        let state = {
            player: null,
            ui: { 
                isFocused: false, 
                isLayoutEditMode: false,
                selectedInventoryId: null, 
                selectedGemId: null,
                activeTab: 'socket',
                activeSocketView: 'visual',
                selectedGemForSocketing: null,
                itemFilter: { category: 'All', subType: 'All', tier: 'All' },
                gemFilter: { type: 'All', grade: 'All' }
            },
            game: { combatActive: false, currentZoneTier: 1, globalJackpot: 0},
            zone: {
                name: "Silverdale",
            },
            keyState: { up: false, left: false, down: false, right: false, interact: false },
            firebase: {
                db: null,
                auth: null,
                userId: null,
                playerDocRef: null,
            },
            chat: {
                currentChannel: 'main',
                unsubscribeListener: null,
            }
        };

        // GDD (Game Design Document) as Code
        const GDD = {
            UNSOCKET_COST: 250,
            MAX_TIER: 20,
            FORMULAS: {
                XP_BASE: 200, XP_GROWTH_RATE: 1.12, AP_PER_LEVEL: 40, AP_VIT_MULTIPLIER: 1.5, AP_OFF_STAT_PENALTY: 0.75,
                HP_BASE: 100, HP_PER_VIT: 10, WC_DEX_SCALING: 0.0055, SC_WIS_SCALING: 0.0055, SC_DEX_SCALING_HYBRID: 0.0055,
                AC_VIT_SCALING: 0.0075, HIT_CHANCE_BASE: 90, HIT_CHANCE_DEX_SCALING: 0.05, HIT_CHANCE_WIS_SCALING: 0.05,
                CRIT_CHANCE_BASE: 5, CRIT_CHANCE_DEX_SCALING: 0.01,
                CRIT_CHANCE_WIS_SCALING: 0.01, CRIT_DAMAGE_MULTIPLIER: 1.5,
                PLAYER_DAMAGE_CONSTANT: 90, HYBRID_SPELLSTRIKE_MULTIPLIER: 0.6,
                MONSTER_DAMAGE_AC_REDUCTION_FACTOR: 0.5,
                RACIAL_POWER_SINGLE_STAT_SCALING: 0.10,
                RACIAL_POWER_DUAL_STAT_SCALING: 0.05, HYBRID_MASTERY_EFFICIENCY: 0.6,
                BASE_ITEM_CLASS_VALUE: 13, BASE_ITEM_GROWTH_RATE: 1.22
            },
            RACES: {
                human: { name: 'Human', archetype: 'True Fighter', cci: 'Sword/Sword', weights: { STR: 8, DEX: 14, VIT: 18, NTL: 5, WIS: 5 }},
                dragonborn: { name: 'Dragonborn', archetype: 'True Fighter', cci: 'Sword/Sword', weights: { STR: 18, DEX: 8, VIT: 8, NTL: 9, WIS: 7 }},
                orc: { name: 'Orc', archetype: 'True Fighter', cci: 'Mace/Mace', weights: { STR: 18, DEX: 6, VIT: 12, NTL: 2, WIS: 2 }},
                werewolf: { name: 'Werewolf', archetype: 'True Fighter', cci: 'Claw/Claw', weights: { STR: 16, DEX: 12, VIT: 18, NTL: 2, WIS: 2 }},
                minotaur: { name: 'Minotaur', archetype: 'True Fighter', cci: 'Axe/Axe', weights: { STR: 16, DEX: 8, VIT: 18, NTL: 2, WIS: 2 }},
                troll: { name: 'Troll', archetype: 'True Fighter', cci: 'Staff/Staff', weights: { STR: 14, DEX: 8, VIT: 14, NTL: 2, WIS: 2 }},
                hobbit: { name: 'Hobbit', archetype: 'True Fighter', cci: 'Dagger/Dagger', weights: { STR: 4, DEX: 20, VIT: 12, NTL: 2, WIS: 2 }},
                centaur: { name: 'Centaur', archetype: 'True Fighter', cci: 'Bow/Arrow', weights: { STR: 12, DEX: 16, VIT: 18, NTL: 2, WIS: 2 }},
                phoenix: {name: 'Phoenix', archetype: 'True Caster', cci: 'Fire/Fire', weights: { STR: 2, DEX: 4, VIT: 16, NTL: 20, WIS: 8}},
                tiefling: {name: 'Tiefling', archetype: 'True Caster', cci: 'Fire/Fire', weights: { STR: 2, DEX: 6, VIT: 6, NTL: 18, WIS: 8}},
                mermaid: { name: 'Mermaid', archetype: 'True Caster', cci: 'Cold/Cold', weights: { STR: 2, DEX: 4, VIT: 4, NTL: 16, WIS: 14 }},
                gnome: {name: 'Gnome', archetype: 'True Caster', cci: 'Earth/Earth', weights: { STR: 2, DEX: 2, VIT: 6, NTL: 12, WIS: 18 }},
                griffin: { name: 'Griffin', archetype: 'True Caster', cci: 'Air/Air', weights: { STR: 4, DEX: 4, VIT: 18, NTL: 12, WIS: 12 }},
                vampire: { name: 'Vampire', archetype: 'True Caster', cci: 'Drain/Drain', weights: { STR: 4, DEX: 12, VIT: 16, NTL: 4, WIS: 14 }},
                elf: { name: 'Elf', archetype: 'True Caster', cci: 'Arcane/Arcane', weights: { STR: 6, DEX: 14, VIT: 6, NTL: 12, WIS: 12 }},
                babayaga: {name: 'Baba Yaga', archetype: 'True Caster', cci: 'Death/Death', weights: { STR: 2, DEX: 12, VIT: 6, NTL: 18, WIS: 12}},
                dwarf: { name: 'Dwarf', archetype: 'Hybrid', cci: 'Axe/Fire', weights: { STR: 12, DEX: 8, VIT: 10, NTL: 12, WIS: 8 }},
                aasimar: { name: 'Aasimar', archetype: 'Hybrid', cci: 'Mace/Arcane', weights: { STR: 8, DEX: 4, VIT: 4, NTL: 12, WIS: 12 }},
                demon: { name: 'Demon', archetype: 'Hybrid', cci: 'Staff/Fire', weights: { STR: 16, DEX: 4, VIT: 10, NTL: 16, WIS: 4 }},
                angel: { name: 'Angel', archetype: 'Hybrid', cci: 'Sword/Arcane', weights: { STR: 9, DEX: 9, VIT: 6, NTL: 16, WIS: 10 }},
                unicorn: { name: 'Unicorn', archetype: 'Hybrid', cci: 'Sword/Death', weights: { STR: 2, DEX: 4, VIT: 6, NTL: 12, WIS: 16 }},
                halfling: { name: 'Halfling', archetype: 'Hybrid', cci: 'Staff/Arcane', weights: { STR: 4, DEX: 18, VIT: 8, NTL: 2, WIS: 18}},
                banshee: { name: 'Banshee', archetype: 'Hybrid', cci: 'Staff/Death', weights: { STR: 4, DEX: 12, VIT: 6, NTL: 18, WIS: 12 }},
                draugr: { name: 'Draugr', archetype: 'Hybrid', cci: 'Dagger/Arcane', weights: { STR: 2, DEX: 4, VIT: 4, NTL: 16, WIS: 12 }},
            },
            ITEMS: {
                baseItemTemplates: [
                    { id: 'base_helm_1', name: 'Helmet', type: 'Armor', subType: 'Helmet', imageUrl: 'https://raw.githubusercontent.com/juugboytv/Geminus/refs/heads/juugboytv-equipment1/IMG_1396.png', sockets: 2},
                    { id: 'base_armor_1', name: 'Armor', type: 'Armor', subType: 'Armor', imageUrl: 'https://raw.githubusercontent.com/juugboytv/Geminus/refs/heads/juugboytv-equipment1/IMG_1401.png', sockets: 2},
                    { id: 'base_gauntlets_1', name: 'Gauntlets', type: 'Armor', subType: 'Gauntlets', imageUrl: 'https://raw.githubusercontent.com/juugboytv/Geminus/main/IMG_1402.png', sockets: 2},
                    { id: 'base_sword_1', name: 'Sword', type: 'Weapons', subType: 'Sword', imageUrl: 'https://raw.githubusercontent.com/juugboytv/Geminus/Weapons/IMG_1412.png', sockets: 2 },
                    { id: 'base_axe_1', name: 'Axe', type: 'Weapons', subType: 'Axe', imageUrl: 'https://raw.githubusercontent.com/juugboytv/Geminus/Weapons/IMG_1413.png', sockets: 2 },
                    { id: 'base_staff_1', name: 'Staff', type: 'Weapons', subType: 'Staff', imageUrl: 'https://raw.githubusercontent.com/juugboytv/Geminus/Weapons/IMG_1416.png', sockets: 2 },
                    { id: 'base_firespell_1', name: 'FireSpell', type: 'Spells', subType: 'Fire', imageUrl: 'https://raw.githubusercontent.com/juugboytv/Geminus/refs/heads/Spells/IMG_1422.png', sockets: 2 },
                    { id: 'base_airspell_1', name: 'AirSpell', type: 'Spells', subType: 'Air', imageUrl: 'https://raw.githubusercontent.com/juugboytv/Geminus/Spells/IMG_1423.png', sockets: 2 },
                    { id: 'base_deathspell_1', name: 'Death', type: 'Spells', subType: 'Death Drain', imageUrl: 'https://raw.githubusercontent.com/juugboytv/Geminus/Spells/IMG_1425.png', sockets: 2 },
                ]
            },
            GEMS: {
                warstone: { name: 'WarStone', type: 'Fighter', abbreviation: 'WST', color: 'var(--glow-fighter)', imageUrl: 'https://raw.githubusercontent.com/juugboytv/Geminus/refs/heads/Gems/IMG_1503.png', stats: 'Adds +10 Attack' },
                mightstone: { name: 'MightStone', type: 'Fighter', abbreviation: 'MGS', color: 'var(--glow-fighter)', imageUrl: 'https://raw.githubusercontent.com/juugboytv/Geminus/refs/heads/Gems/IMG_1517.png', stats: 'Adds +5 Strength' },
                obsidian_heart: { name: 'ObsidianHeart', type: 'Misc', abbreviation: 'OH', color: 'var(--glow-misc)', imageUrl: 'https://raw.githubusercontent.com/juugboytv/Geminus/refs/heads/Gemsmisc/IMG_1540.png', stats: '+15% Vitality' },
                ascend_core: { name: 'AcendCore', type: 'Misc', abbreviation: 'ASC', color: 'var(--glow-misc)', imageUrl: 'https://raw.githubusercontent.com/juugboytv/Geminus/refs/heads/Gemsmisc/IMG_1528.png', stats: '+5% XP Gain' },
                air_totem: { name: 'AirTotem', type: 'Caster', abbreviation: 'AIR', color: 'var(--glow-caster)', imageUrl: 'https://raw.githubusercontent.com/juugboytv/Geminus/Gems/IMG_1512.png', stats: '+10 Air Damage' },
                death_shard: { name: 'DeathShard', type: 'Caster', abbreviation: 'DTH', color: 'var(--glow-caster)', imageUrl: 'https://raw.githubusercontent.com/juugboytv/Geminus/Gems/IMG_1515.png', stats: '+10% Lifesteal' },
            },
            gemCategories: {
                'Fighter': { ids: ['warstone', 'mightstone'] },
                'Utility': { ids: ['obsidian_heart'] },
                'Farming': { ids: ['ascend_core'] },
            },
            GemGradeUnlockLevels: [1, 100, 253, 1000, 6143, 13636, 35452, 83333, 172222],
            equipmentSlotConfig: [
                { name: 'Helmet', type: 'Armor' }, { name: 'Weapon 1', type: 'Weapons' },
                { name: 'Armor', type: 'Armor' }, { name: 'Weapon 2', type: 'Weapons' },
                { name: 'Gauntlets', type: 'Armor' }, { name: 'Leggings', type: 'Armor' },
                { name: 'Boots', type: 'Armor' }, { name: 'Amulet', type: 'Amulet' },
                { name: 'Spell 1', type: 'Spells' }, { name: 'Ring', type: 'Ring' },
                { name: 'Spell 2', type: 'Spells' }
            ],
        };

        // --- UI Elements
        const ui = {};
        document.querySelectorAll('[id]').forEach(el => {
            const camelCaseId = el.id.replace(/-(\w)/g, (m, g) => g.toUpperCase());
            ui[camelCaseId] = el;
        });

        // --- Utility Functions
        function showToast(message, isError = false) {
            ui.toastNotification.textContent = message;
            ui.toastNotification.className = `glass-panel fixed left-1/2 -translate-x-1/2 z-[210] transition-all duration-500 ease-in-out px-6 py-3 rounded-lg font-semibold ${isError ? 'toast-error' : 'toast-success'}`;
            ui.toastNotification.style.bottom = '5rem';
            setTimeout(() => { ui.toastNotification.style.bottom = '-100px'; }, 3000);
        }
        
        // --- Smoke Canvas Animation ---
        const smokeCanvas = document.getElementById('smoke-canvas');
        const smokeCtx = smokeCanvas.getContext('2d');
        smokeCanvas.width = window.innerWidth;
        smokeCanvas.height = window.innerHeight;

        let smokeParticles = [];
        const smokeParticleCount = 75;

        class SmokeParticle {
            constructor(color) {
                this.x = Math.random() * smokeCanvas.width;
                this.y = Math.random() * smokeCanvas.height;
                this.size = Math.random() * 150 + 50;
                this.speedX = Math.random() * 0.4 - 0.2;
                this.speedY = Math.random() * 0.4 - 0.2;
                this.color = color;
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                if (this.x < -this.size) this.x = smokeCanvas.width + this.size;
                if (this.x > smokeCanvas.width + this.size) this.x = -this.size;
                if (this.y < -this.size) this.y = smokeCanvas.height + this.size;
                if (this.y > smokeCanvas.height + this.size) this.y = -this.size;
            }
            draw() {
                smokeCtx.fillStyle = this.color;
                smokeCtx.beginPath();
                smokeCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                smokeCtx.filter = 'blur(60px)';
                smokeCtx.fill();
            }
        }

        function initSmokeParticles(theme) {
            smokeParticles = [];
            const color = theme === 'molten-core' 
                ? `rgba(249, 115, 22, ${Math.random() * 0.07})`
                : `rgba(34, 211, 238, ${Math.random() * 0.07})`;

            for (let i = 0; i < smokeParticleCount; i++) {
                smokeParticles.push(new SmokeParticle(color));
            }
        }

        function updateSmokeParticleColors(theme) {
            const color = theme === 'molten-core' 
                ? `rgba(249, 115, 22, ${Math.random() * 0.07})`
                : `rgba(34, 211, 238, ${Math.random() * 0.07})`;
            smokeParticles.forEach(p => {
                p.color = color;
            });
        }

        function animateSmoke() {
            smokeCtx.clearRect(0, 0, smokeCanvas.width, smokeCanvas.height);
            for (let i = 0; i < smokeParticles.length; i++) {
                smokeParticles[i].update();
                smokeParticles[i].draw();
            }
            requestAnimationFrame(animateSmoke);
        }

        window.addEventListener('resize', () => {
            smokeCanvas.width = window.innerWidth;
            smokeCanvas.height = window.innerHeight;
            const currentTheme = localStorage.getItem('geminusTheme') || 'aetherial-shard';
            initSmokeParticles(currentTheme);
            if(WorldMapManager.isInitialized) {
                WorldMapManager.isInitialized = false; // Force re-init to handle canvas resize
                WorldMapManager.init();
            }
        });

        animateSmoke();


        // --- NEW Data Manager (Firebase) ---
        const DataManager = {
            async init() {
                try {
                    // =======================================================================
                    // PASTE YOUR FIREBASE CONFIG OBJECT HERE
                    // =======================================================================
                     const firebaseConfig = {
                        apiKey: "AIzaSyA8wfcXLXVP2KanuhGPQeKnOeeGPDRKLzk",
                        authDomain: "gem-inus-on-ga-me.firebaseapp.com",
                        projectId: "gem-inus-on-ga-me",
                        storageBucket: "gem-inus-on-ga-me.appspot.com",
                        messagingSenderId: "663073930106",
                        appId: "1:663073930106:web:dbf2001917e856150134c3"
                    };                
                    // =======================================================================


                    if (!firebaseConfig.apiKey.startsWith("AIza")) {
                        ModalManager.show("Configuration Needed", `<div class="text-center"><p class="mb-4">Welcome, Developer!</p><p>To enable saving, you need to add your Firebase configuration to the <strong>script.js</strong> file.</p><p class="mt-2 text-sm text-gray-400">Please follow the instructions to create a Firebase project and paste the config object into the designated area in the code.</p></div>`);
                        return;
                    }

                    const appId = 'geminus-game'; // A unique ID for your app's data

                    const app = window.firebase.initializeApp(firebaseConfig);
                    state.firebase.db = window.firebase.getFirestore(app);
                    state.firebase.auth = window.firebase.getAuth(app);

                    // Authenticate the user anonymously
                    await window.firebase.signInAnonymously(state.firebase.auth);

                    state.firebase.userId = state.firebase.auth.currentUser.uid;
                    if (!state.firebase.userId) {
                        throw new Error("Anonymous authentication failed.");
                    }

                    const userDocPath = `/artifacts/${appId}/users/${state.firebase.userId}`;
                    state.firebase.playerDocRef = window.firebase.doc(state.firebase.db, userDocPath);

                    console.log("Firebase initialized and user authenticated:", state.firebase.userId);
                    await this.loadPlayer();

                } catch (error) {
                    console.error("Error initializing Firebase or loading data:", error);
                    showToast("Could not connect to the game server.", true);
                    CreationManager.init();
                }
            },

            async loadPlayer() {
                try {
                    const docSnap = await window.firebase.getDoc(state.firebase.playerDocRef);
                    if (docSnap.exists()) {
                        console.log("Player data found, loading character...");
                        state.player = docSnap.data();
                        // Ensure nested objects are correctly parsed if they were stringified
                        if(typeof state.player.inventory === 'string') state.player.inventory = JSON.parse(state.player.inventory);
                        if(typeof state.player.equipment === 'string') state.player.equipment = JSON.parse(state.player.equipment);
                        if(typeof state.player.gems === 'string') state.player.gems = JSON.parse(state.player.gems);
                        
                        GameManager.init(); // Start the game with loaded data
                    } else {
                        console.log("No player data found, starting character creation.");
                        CreationManager.init(); // Show character creation screen
                    }
                } catch (error) {
                    console.error("Error loading player data:", error);
                    showToast("Failed to load your character.", true);
                    CreationManager.init();
                }
            },

            async savePlayer(playerData) {
                if (!state.firebase.playerDocRef) {
                    console.error("Cannot save: Firebase is not initialized.");
                    return;
                }
                try {
                    // Firestore works best with plain objects. Stringify complex/nested arrays/objects.
                    const dataToSave = {
                        ...playerData,
                        inventory: JSON.stringify(playerData.inventory),
                        equipment: JSON.stringify(playerData.equipment),
                        gems: JSON.stringify(playerData.gems),
                        lastSaved: window.firebase.serverTimestamp()
                    };
                    await window.firebase.setDoc(state.firebase.playerDocRef, dataToSave);
                    console.log("Player data saved successfully.");
                } catch (error) {
                    console.error("Error saving player data:", error);
                    showToast("Failed to save character progress.", true);
                }
            },
            
            // Use this for frequent updates to specific fields
            async updatePlayer(fieldsToUpdate) {
                 if (!state.firebase.playerDocRef) {
                    console.error("Cannot update: Firebase is not initialized.");
                    return;
                }
                try {
                    const updates = {...fieldsToUpdate};
                    // Stringify any object/array fields before updating
                    for(const key in updates) {
                        if(typeof updates[key] === 'object' && updates[key] !== null) {
                            updates[key] = JSON.stringify(updates[key]);
                        }
                    }
                    updates.lastSaved = window.firebase.serverTimestamp();
                    await window.firebase.updateDoc(state.firebase.playerDocRef, updates);
                } catch (error) {
                    // This might happen if the doc doesn't exist yet, so we do a full save.
                    if (error.code === 'not-found') {
                        await this.savePlayer(state.player);
                    } else {
                        console.error("Error updating player data:", error);
                    }
                }
            }
        };

        // --- NEW Chat Manager ---
        const ChatManager = {
            isInitialized: false,
            
            init() {
                if (this.isInitialized) return;
                this.isInitialized = true;
                this.addEventListeners();
                this.switchChannel('main'); // Start listening to the main channel
                console.log("Chat Manager Initialized");
            },

            addEventListeners() {
                // Footer chat form
                ui.footerMessageForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    const input = ui.footerMessageInput;
                    if (input.value.trim()) {
                        this.sendMessage(input.value.trim());
                        input.value = '';
                    }
                });

                // Full modal chat form
                ui.messageForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    const input = ui.messageInput;
                    if (input.value.trim()) {
                        this.sendMessage(input.value.trim());
                        input.value = '';
                    }
                });
                
                // Channel switching for footer
                ui.footerChatContainer.addEventListener('click', e => {
                    const tab = e.target.closest('.footer-tab-button');
                    if(tab && !tab.id.includes('open-chat')) {
                        this.switchChannel(tab.dataset.channel);
                    }
                });

                // Channel switching for modal
                ui.tabsContainer.addEventListener('click', e => {
                    const tab = e.target.closest('.tab');
                    if(tab) {
                        this.switchChannel(tab.dataset.channel);
                    }
                });
                
                // Open/close full chat modal
                ui.openChatModalBtn.addEventListener('click', () => ui.chatModal.classList.remove('hidden'));
                ui.closeChatModalBtn.addEventListener('click', () => ui.chatModal.classList.add('hidden'));
            },
            
            async sendMessage(text) {
                if (!state.firebase.db || !state.player) {
                    showToast("You must be logged in to chat.", true);
                    return;
                }
                
                const message = {
                    userId: state.firebase.userId,
                    username: state.player.name,
                    text: text,
                    timestamp: window.firebase.serverTimestamp()
                };

                try {
                    const channelRef = window.firebase.collection(state.firebase.db, 'chat', state.chat.currentChannel, 'messages');
                    await window.firebase.addDoc(channelRef, message);
                } catch (error) {
                    console.error("Error sending message:", error);
                    showToast("Message could not be sent.", true);
                }
            },

            listenForMessages(channel) {
                // Unsubscribe from the old channel's listener if it exists
                if (state.chat.unsubscribeListener) {
                    state.chat.unsubscribeListener();
                }

                const messagesRef = window.firebase.collection(state.firebase.db, 'chat', channel, 'messages');
                const q = window.firebase.query(messagesRef, window.firebase.orderBy('timestamp', 'asc'), window.firebase.limitToLast(50));

                state.chat.unsubscribeListener = window.firebase.onSnapshot(q, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === "added") {
                            this.renderMessage(change.doc.data());
                        }
                    });
                }, (error) => {
                    console.error("Error listening for messages:", error);
                });
            },

            renderMessage(data) {
                const isCurrentUser = data.userId === state.firebase.userId;
                const messageHTML = `
                    <div class="message-wrapper flex ${isCurrentUser ? 'justify-end' : 'justify-start'}">
                        <div class="chat-bubble p-2 rounded-lg max-w-[80%] ${isCurrentUser ? 'chat-bubble-user' : 'chat-bubble-other'}">
                            ${!isCurrentUser ? `<p class="font-bold text-xs" style="color: var(--highlight-color);">${data.username}</p>` : ''}
                            <p class="text-sm">${data.text}</p>
                        </div>
                    </div>
                `;
                
                // Append to both chat views
                ui.footerChatContentWrapper.innerHTML += messageHTML;
                ui.chatMessages.innerHTML += messageHTML;

                // Auto-scroll to the bottom
                ui.footerChatContentWrapper.scrollTop = ui.footerChatContentWrapper.scrollHeight;
                ui.chatMessages.scrollTop = ui.chatMessages.scrollHeight;
            },

            switchChannel(newChannel) {
                if (state.chat.currentChannel === newChannel) return;

                state.chat.currentChannel = newChannel;
                
                // Clear UI
                ui.footerChatContentWrapper.innerHTML = '';
                ui.chatMessages.innerHTML = '';
                
                // Update active tab styles
                document.querySelectorAll('.footer-tab-button, #tabs-container .tab').forEach(tab => {
                    if(tab.dataset.channel === newChannel) {
                        tab.classList.add('active');
                    } else {
                        tab.classList.remove('active');
                    }
                });

                this.listenForMessages(newChannel);
                console.log(`Switched to chat channel: ${newChannel}`);
            }
        };


        // --- Manager Implementations ---
        const SettingsManager = {
            isInitialized: false,
            init() {
                if (this.isInitialized) return;
                this.isInitialized = true;
                this.render();
                this.addEventListeners();
                this.updateButtonStates();
            },
            render() {
                const settingsContainer = ui.tabContentSettings;
                settingsContainer.innerHTML = `
                <div class="space-y-4">
                    <div class="stat-accordion-item open">
                        <button class="stat-accordion-header">
                            <h3 class="text-glow-subtle font-orbitron">UI Theme</h3>
                            <svg class="accordion-arrow w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>
                        </button>
                        <div class="stat-accordion-content">
                            <p class="text-sm text-gray-400 mb-4">Select a visual theme for the game interface.</p>
                            <div class="flex flex-col sm:flex-row gap-4">
                                <button class="theme-select-btn glass-button w-full py-3 rounded-md" data-theme="aetherial-shard">Aetherial Shard</button>
                                <button class="theme-select-btn glass-button w-full py-3 rounded-md" data-theme="molten-core">Molten Core</button>
                            </div>
                        </div>
                    </div>
                </div>`;
            },
            addEventListeners() {
                const settingsContainer = ui.tabContentSettings;
                settingsContainer.addEventListener('click', e => {
                    const themeBtn = e.target.closest('.theme-select-btn');
                    if (themeBtn) {
                        this.setTheme(themeBtn.dataset.theme);
                    }
                });
            },
            setTheme(themeName) {
                document.body.className = `theme-${themeName}`;
                localStorage.setItem('geminusTheme', themeName);
                this.updateButtonStates();
                updateSmokeParticleColors(themeName);
            },
            loadTheme() {
                const savedTheme = localStorage.getItem('geminusTheme') || 'aetherial-shard';
                this.setTheme(savedTheme);
                initSmokeParticles(savedTheme);
            },
            updateButtonStates() {
                const currentTheme = localStorage.getItem('geminusTheme') || 'aetherial-shard';
                document.querySelectorAll('.theme-select-btn').forEach(btn => {
                    if (btn.dataset.theme === currentTheme) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
            }
        };

        // --- World Map Manager (Square Grid) ---
        const WorldMapManager = {
            isInitialized: false,
            grid: [], // Stores the map data as a 2D array
            tileSize: 0,
            ctx: null,
            GRID_SIZE: 7, // Defines a 7x7 grid

            init() {
                if (this.isInitialized) return;
                this.isInitialized = true;

                const container = ui.miniMapContainer;
                const canvas = ui.miniMapCanvas;
                if (!container || !canvas) return;
                
                const dpr = window.devicePixelRatio || 1;
                canvas.width = container.clientWidth * dpr;
                canvas.height = container.clientHeight * dpr;
                canvas.style.width = `${container.clientWidth}px`;
                canvas.style.height = `${container.clientHeight}px`;
                
                this.ctx = canvas.getContext('2d');
                this.ctx.scale(dpr, dpr);

                if (this.grid.length === 0) {
                    this.generateGrid();
                }
                this.updateInteractButton();
                this.draw();
            },

            generateGrid() {
                this.grid = [];
                for (let y = 0; y < this.GRID_SIZE; y++) {
                    const row = [];
                    for (let x = 0; x < this.GRID_SIZE; x++) {
                        // Default tile
                        row.push({ feature: { name: 'Monster Zone', icon: '', color: 'rgba(50, 50, 50, 0.5)' } });
                    }
                    this.grid.push(row);
                }
                // Define special locations with custom colors
                this.grid[3][3].feature = { name: 'Start', icon: '🏠', color: 'rgba(50, 50, 50, 0.5)' };
                this.grid[2][4].feature = { name: 'Weapons/Combat Shop', icon: '⚔️', color: 'rgba(50, 50, 50, 0.5)' };
                this.grid[4][2].feature = { name: 'Magic/Accessories Shop', icon: '🔮', color: 'rgba(50, 50, 50, 0.5)' };
                this.grid[3][5].feature = { name: 'Bank', icon: '🏧', color: 'rgba(50, 50, 50, 0.5)' };
                this.grid[3][1].feature = { name: 'Sanctuary', icon: '🆘', color: 'rgba(50, 50, 50, 0.5)' };
                this.grid[5][3].feature = { name: 'Teleport Zone', icon: '🌀', color: 'rgba(50, 50, 50, 0.5)' };
            },

            movePlayer(dx, dy) {
                if (!state.player) return;
                const newX = state.player.pos.x + dx;
                const newY = state.player.pos.y + dy;
                
                // Edge Detection
                if (newY >= 0 && newY < this.GRID_SIZE && newX >= 0 && newX < this.GRID_SIZE) {
                    state.player.pos.x = newX;
                    state.player.pos.y = newY;
                    this.draw();
                    this.updateInteractButton();
                    UIManager.updatePlayerStatusUI();
                    DataManager.updatePlayer({ pos: state.player.pos });
                }
            },

            updateInteractButton() {
                if (!state.player) return;
                const currentTile = this.grid[state.player.pos.y][state.player.pos.x];
                const interactKey = document.getElementById('key-interact');
                if (currentTile.feature && currentTile.feature.name !== 'Monster Zone' && currentTile.feature.name !== 'Start') {
                    interactKey.textContent = `Enter`;
                    interactKey.style.fontSize = '16px';
                } else {
                    interactKey.textContent = 'Interact';
                    interactKey.style.fontSize = '18px';
                }
            },

            handleInteraction() {
                if (!state.player) return;
                const currentTile = this.grid[state.player.pos.y][state.player.pos.x];
                if (currentTile && currentTile.feature && currentTile.feature.name !== 'Monster Zone') {
                    console.log(`Interacting with: ${currentTile.feature.name}`);
                    showToast(`You are at the ${currentTile.feature.name}.`);
                } else {
                    showToast(`Nothing to interact with here.`);
                }
            },

            draw() {
                if (!this.ctx || !state.player) return;
                const container = ui.miniMapContainer;
                const ctx = this.ctx;
                ctx.clearRect(0, 0, container.clientWidth, container.clientHeight);
                
                // Create a Circular Clipping Mask
                ctx.save();
                ctx.beginPath();
                ctx.arc(container.clientWidth / 2, container.clientHeight / 2, container.clientWidth / 2, 0, Math.PI * 2);
                ctx.clip();
                
                const viewRadius = 2; // Zoomed in
                this.tileSize = container.clientWidth / (viewRadius * 2 + 1);

                const centerX = container.clientWidth / 2;
                const centerY = container.clientHeight / 2;

                for (let y = 0; y < this.GRID_SIZE; y++) {
                    for (let x = 0; x < this.GRID_SIZE; x++) {
                        const relX = x - state.player.pos.x;
                        const relY = y - state.player.pos.y;
                        
                        const pixelX = centerX + relX * this.tileSize - this.tileSize / 2;
                        const pixelY = centerY + relY * this.tileSize - this.tileSize / 2;

                        this.drawSquare(pixelX, pixelY, this.tileSize, this.grid[y][x].feature);
                    }
                }
                
                this.drawPlayer(centerX - this.tileSize / 2, centerY - this.tileSize / 2);

                // Restore the context to remove the clipping mask
                ctx.restore();
            },

            drawSquare(px, py, size, feature) {
                this.ctx.fillStyle = feature.color || 'rgba(10, 10, 10, 0.5)';
                this.ctx.fillRect(px, py, size, size);
                
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(px, py, size, size);

                if (feature && feature.icon) {
                    this.ctx.font = `${size * 0.7}px sans-serif`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillStyle = '#f0f0f0';
                    this.ctx.fillText(feature.icon, px + size / 2, py + size / 2);
                }
            },

            drawPlayer(px, py) {
                if (!state.player) return;
                this.ctx.font = `${this.tileSize * 0.7}px sans-serif`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(state.player.icon, px + this.tileSize / 2, py + this.tileSize / 2);
            }
        };

        // --- D-Pad and Keyboard Controls ---
        function initControls() {
            const keyElements = document.querySelectorAll('.game-key');

            const setKeyState = (key, isPressed) => {
                state.keyState[key] = isPressed;
                const keyElement = document.getElementById(`key-${key}`);
                if (keyElement) {
                    keyElement.classList.toggle('pressed', isPressed);
                }
            };
            
            const handleKeyPress = (key) => {
                switch(key) {
                    case 'up': WorldMapManager.movePlayer(0, -1); break;
                    case 'down': WorldMapManager.movePlayer(0, 1); break;
                    case 'left': WorldMapManager.movePlayer(-1, 0); break;
                    case 'right': WorldMapManager.movePlayer(1, 0); break;
                    case 'interact': WorldMapManager.handleInteraction(); break;
                }
            };
            
            // Touch controls
            keyElements.forEach(element => {
                const key = element.dataset.key;
                element.addEventListener('touchstart', (e) => { e.preventDefault(); setKeyState(key, true); handleKeyPress(key); });
                element.addEventListener('touchend', (e) => { e.preventDefault(); setKeyState(key, false); });
                element.addEventListener('mousedown', (e) => { e.preventDefault(); setKeyState(key, true); handleKeyPress(key); });
                element.addEventListener('mouseup', (e) => { e.preventDefault(); setKeyState(key, false); });
                element.addEventListener('mouseleave', () => { if (state.keyState[key]) setKeyState(key, false); });
            });

            // Keyboard controls
            window.addEventListener('keydown', (e) => {
                let key;
                switch(e.key) {
                    case 'ArrowUp': case 'w': key = 'up'; break;
                    case 'ArrowDown': case 's': key = 'down'; break;
                    case 'ArrowLeft': case 'a': key = 'left'; break;
                    case 'ArrowRight': case 'd': key = 'right'; break;
                    case 'Enter': case ' ': key = 'interact'; break;
                    default: return;
                }
                e.preventDefault();
                if (!state.keyState[key]) { // Prevent rapid repeat on keydown
                    setKeyState(key, true);
                    handleKeyPress(key);
                }
            });

            window.addEventListener('keyup', (e) => {
                let key;
                switch(e.key) {
                    case 'ArrowUp': case 'w': key = 'up'; break;
                    case 'ArrowDown': case 's': key = 'down'; break;
                    case 'ArrowLeft': case 'a': key = 'left'; break;
                    case 'ArrowRight': case 'd': key = 'right'; break;
                    case 'Enter': case ' ': key = 'interact'; break;
                    default: return;
                }
                e.preventDefault();
                setKeyState(key, false);
            });
        }

        const ModalManager = {
            show(title, contentHTML, options = {}) {
                const { widthClass = 'w-11/12 max-w-lg', onContentReady } = options;
                ui.modalContainer.innerHTML = `
                <div class="modal-backdrop">
                    <div class="glass-panel p-4 rounded-lg flex flex-col ${widthClass}">
                        <div class="flex-shrink-0 flex justify-between items-center mb-4">
                            <h3 class="font-orbitron text-xl capitalize text-glow-subtle">${title}</h3>
                            <button id="modal-close-btn" class="text-2xl leading-none transition-colors hover:text-[var(--highlight-color)]">&times;</button>
                        </div>
                        <div id="modal-content-body" class="flex-grow overflow-y-auto custom-scrollbar">${contentHTML}</div>
                    </div>
                </div>`;
                ui.modalContainer.querySelector('#modal-close-btn').onclick = () => this.hide();
                if (onContentReady) {
                    onContentReady(ui.modalContainer.querySelector('#modal-content-body'));
                }
            },
            hide() {
                ui.modalContainer.innerHTML = "";
            }
        };

        const CreationManager = {
            init() {
                const contentHTML = `
                <div class="creation-card w-full h-full flex flex-col">
                    <div class="flex-shrink-0">
                        <h1 class="text-3xl font-orbitron text-center mb-4 text-glow-label">Create Your Hero</h1>
                        <div class="mb-4 px-4">
                            <input type="text" id="creation-player-name" placeholder="Enter Character Name" class="w-full text-lg editor-input">
                        </div>
                        <h2 class="text-xl font-orbitron text-center mb-4 text-glow-subtle">Choose Your Race</h2>
                    </div>
                    <div id="creation-race-grid" class="flex-grow overflow-y-auto custom-scrollbar grid grid-cols-2 md:grid-cols-4 gap-2 px-4">
                        ${Object.keys(GDD.RACES).map(raceId => `
                            <div class="race-option p-3 text-center border border-transparent rounded-md cursor-pointer hover:bg-[rgba(var(--highlight-color-rgb),0.2)] font-orbitron text-glow-subtle" data-race="${raceId}">${GDD.RACES[raceId].name}</div>
                        `).join("")}
                    </div>
                    <div class="flex-shrink-0 mt-4 px-4">
                        <button id="finish-creation-btn" class="glass-button w-full py-3 font-bold rounded-md" disabled>Finish</button>
                    </div>
                </div>`;
                ModalManager.show('Create Your Character', contentHTML, {
                    widthClass: 'w-full max-w-3xl h-full sm:h-auto sm:max-h-[90vh]',
                    onContentReady: (contentDiv) => {
                        let selectedRace = null;
                        const finishBtn = contentDiv.querySelector('#finish-creation-btn');
                        const nameInput = contentDiv.querySelector('#creation-player-name');
                        const checkCanFinish = () => {
                            const name = nameInput.value.trim();
                            finishBtn.disabled = !selectedRace || name.length < 3;
                        };
                        contentDiv.querySelectorAll('.race-option').forEach(option => {
                            option.addEventListener('click', () => {
                                selectedRace = option.dataset.race;
                                contentDiv.querySelectorAll('.race-option').forEach(el => el.style.backgroundColor = 'transparent');
                                option.style.backgroundColor = `rgba(var(--highlight-color-rgb), 0.3)`;
                                checkCanFinish();
                            });
                        });
                        nameInput.addEventListener('input', checkCanFinish);
                        finishBtn.addEventListener('click', () => {
                            const playerName = nameInput.value.trim();
                            this.finishCreation(playerName, selectedRace);
                        });
                    },
                });
            },
            async finishCreation(playerName, raceId) {
                if (!raceId || !playerName) return;
                const raceData = GDD.RACES[raceId];
                state.player = {
                    name: playerName,
                    level: 1, xp: 0, gold: 1000,
                    xpToNextLevel: GDD.FORMULAS.XP_BASE,
                    attributePoints: GDD.FORMULAS.AP_PER_LEVEL,
                    race: raceData.name,
                    archetype: raceData.archetype,
                    cci: raceData.cci,
                    baseStats: {...raceData.weights },
                    stats: {},
                    inventory: [],
                    equipment: {},
                    gems: [],
                    lastItemDrop: null,
                    lastGemDrop: null,
                    defeatedBosses: [],
                    pos: { x: 3, y: 3 }, 
                    icon: '👤'
                };
                GDD.equipmentSlotConfig.forEach(slot => state.player.equipment[slot.name] = null);
                this.generateStartingGear();
                ProfileManager.calculateAllStats();
                state.player.hp = state.player.stats.maxHp;
                
                await DataManager.savePlayer(state.player);

                ModalManager.hide();
                GameManager.init();
            },
            generateStartingGear() {
                const itemTypes = ['Dropper', 'Shadow', 'Echo'];
                GDD.ITEMS.baseItemTemplates.forEach(baseItem => {
                    for(let i = 1; i <= 5; i++) {
                        const newItem = {
                            instanceId: `${baseItem.id}_${Date.now()}_${Math.random()}`,
                            baseItemId: baseItem.id,
                            tier: Math.ceil(Math.random()* 10),
                            type: itemTypes[Math.floor(Math.random() * itemTypes.length)],
                            socketedGems: []
                        };
                        if (Math.random() > 0.7) {
                            newItem.socketedGems.push({ id: 'warstone', grade: 1 });
                        }
                        state.player.inventory.push(newItem);
                    }
                });
                Object.keys(GDD.GEMS).forEach(gemId => {
                    state.player.gems.push({ id: gemId, grade: Math.ceil(Math.random() * 3) });
                });
            }
        };

        const ProfileManager = {
            addXp(amount, xpBonus = 0) {
                if (!state.player) return;
                const finalXp = amount * (1 + xpBonus / 100);
                state.player.xp += finalXp;
                CombatManager.logToGame(`You gained <span class="log-xp">${Math.floor(finalXp)} XP</span>!`);
                while (state.player.xp >= state.player.xpToNextLevel) {
                    this.levelUp();
                }
                this.updateAllProfileUI();
                DataManager.updatePlayer({ xp: state.player.xp, level: state.player.level, xpToNextLevel: state.player.xpToNextLevel, attributePoints: state.player.attributePoints });
            },
            addGold(amount) {
                if (!state.player) return;
                state.player.gold += amount;
                CombatManager.logToGame(`You found <span class="log-gold">${Math.floor(amount)} Gold</span>!`);
                this.updateAllProfileUI();
                DataManager.updatePlayer({ gold: state.player.gold });
            },
            levelUp() {
                state.player.xp -= state.player.xpToNextLevel;
                state.player.level++;
                state.player.xpToNextLevel = Math.floor(GDD.FORMULAS.XP_BASE * Math.pow(GDD.FORMULAS.XP_GROWTH_RATE, state.player.level));
                state.player.attributePoints += GDD.FORMULAS.AP_PER_LEVEL;
                showToast(`You have reached Level ${state.player.level}! You gained ${GDD.FORMULAS.AP_PER_LEVEL} Attribute Points.`);
                this.calculateAllStats();
                state.player.hp = state.player.stats.maxHp;
            },
            spendAttributePoint(clickedAttr) {
                const p = state.player;
                if (p.attributePoints < GDD.FORMULAS.AP_PER_LEVEL) {
                    showToast(`You need ${GDD.FORMULAS.AP_PER_LEVEL} points to allocate.`, true);
                    return;
                }
                const raceData = Object.values(GDD.RACES).find(r => r.name === p.race);
                const weights = raceData.weights;
                const totalWeight = Object.values(weights).reduce((sum, val) => sum + val, 0);
                const pointsPerWeight = GDD.FORMULAS.AP_PER_LEVEL / totalWeight;
                for (const stat in weights) {
                    p.baseStats[stat] += weights[stat] * pointsPerWeight;
                }
                p.attributePoints -= GDD.FORMULAS.AP_PER_LEVEL;
                this.calculateAllStats();
                StatsManager.render();
                UIManager.flashStatUpdate(clickedAttr);
                showToast("Attributes increased!", false);
                DataManager.updatePlayer({ baseStats: p.baseStats, attributePoints: p.attributePoints });
            },
            calculateAllStats() {
                if (!state.player || !state.player.baseStats) return;
                const p = state.player;
                const totalStats = {...p.baseStats, WC: 0, SC: 0, AC: 0, XP_BONUS: 0 };
                for (const slotName in p.equipment) {
                    const instanceId = p.equipment[slotName];
                    if (instanceId) {
                        const item = p.inventory.find(i => i.instanceId === instanceId);
                        const baseItem = GDD.ITEMS.baseItemTemplates.find(b => b.id === item.baseItemId);
                        if (baseItem && baseItem.stats) {
                            for (const stat in baseItem.stats) {
                                totalStats[stat] = (totalStats[stat] || 0) + baseItem.stats[stat];
                            }
                        }
                        if (item.socketedGems) {
                            item.socketedGems.forEach(gemInfo => {
                                if (gemInfo) {
                                    const gemData = GDD.GEMS[gemInfo.id];
                                    const gradeIndex = gemInfo.grade - 1;
                                    if (gemData && gemData.stat && gemData.values && gradeIndex < gemData.values.length) {
                                        totalStats[gemData.stat] = (totalStats[stat] || 0) + gemData.values[gradeIndex];
                                    }
                                }
                            });
                        }
                    }
                }
                p.stats = {}; // Reset calculated stats
                p.stats.maxHp = GDD.FORMULAS.HP_BASE + (totalStats.VIT * GDD.FORMULAS.HP_PER_VIT);
                const baseWc = 10, baseSc = 10, baseAc = 20;
                p.stats.finalWC = (baseWc + totalStats.WC) * (1 + (totalStats.DEX * GDD.FORMULAS.WC_DEX_SCALING));
                p.stats.finalSC = (baseSc + totalStats.SC) * (1 + (totalStats.WIS * GDD.FORMULAS.SC_WIS_SCALING));
                p.stats.finalAC = (baseAc + totalStats.AC) * (1 + (totalStats.VIT * GDD.FORMULAS.AC_VIT_SCALING));
                p.stats.xpBonus = totalStats.XP_BONUS;
                const hitStat = p.archetype === 'True Caster' ? totalStats.WIS : totalStats.DEX;
                const hitScaling = p.archetype === 'True Caster' ? GDD.FORMULAS.HIT_CHANCE_WIS_SCALING : GDD.FORMULAS.HIT_CHANCE_DEX_SCALING;
                p.stats.hitChance = GDD.FORMULAS.HIT_CHANCE_BASE + (hitStat * hitScaling);
                const critStat = p.archetype === 'True Caster' ? totalStats.WIS : totalStats.DEX;
                const critScaling = p.archetype === 'True Caster' ? GDD.FORMULAS.CRIT_CHANCE_WIS_SCALING : GDD.FORMULAS.CRIT_CHANCE_DEX_SCALING;
                p.stats.critChance = GDD.FORMULAS.CRIT_CHANCE_BASE + (critStat * critScaling);
                if (p.hp === undefined || p.hp > p.stats.maxHp) {
                    p.hp = p.stats.maxHp;
                }
                this.updateAllProfileUI();
            },
            updateAllProfileUI() {
                UIManager.updatePlayerStatusUI();
                if (CombatManager.isInitialized) CombatManager.updateCombatInfoPanel();
                if (StatsManager.isInitialized) StatsManager.render();
            }
        };

        const ItemManager = {
            generateAndAwardLoot(tier) {
                if (!state.player) return;
                if (Math.random() < 0.1) {
                    const newItem = { name: `T${tier} Shadow Item` };
                    state.player.lastItemDrop = newItem.name;
                    CombatManager.logToGame(`You found a <span class="log-loot-item">${newItem.name}</span>!`);
                }
                if (Math.random() < 0.2) {
                    const newGem = { name: 'Random Gem' };
                    state.player.lastGemDrop = newGem.name;
                    CombatManager.logToGame(`You found a <span class="log-loot-gem">${newGem.name}</span>!`);
                }
                DataManager.updatePlayer({ lastItemDrop: state.player.lastItemDrop, lastGemDrop: state.player.lastGemDrop });
            },
        };

        const CombatManager = {
            isInitialized: false,
            currentMonster: null,
            logMessages: [],
            init() {
                if (this.isInitialized) return;
                this.isInitialized = true;
                this.render();
                this.addEventListeners();
                this.updateCombatInfoPanel();
                this.populateMonsterList(state.game.currentZoneTier);
                this.logMessages = ['Select a monster to begin combat.'];
                this.renderLog();
            },
            logToGame(message) {
                this.logMessages.push(message);
                if (this.logMessages.length > 5) {
                    this.logMessages.shift();
                }
                this.renderLog();
            },
            renderLog() {
                const logDisplay = document.querySelector('#tab-content-combat #combat-log-display');
                if (logDisplay) {
                    logDisplay.innerHTML = this.logMessages.join('<br>');
                }
            },
            render() {
                 ui.tabContentCombat.innerHTML = `
                <div class="space-y-4 flex flex-col h-full">
                    <div id="combat-info-panel" class="w-full p-2 rounded-lg bg-black/20 border" style="border-color: var(--border-color-main)">
                        <div id="combat-stats-container"></div>
                    </div>
                    <div class="combat-control-bar flex gap-2 p-2 bg-black/20 rounded-lg">
                        <select id="monsterSelect" class="editor-input flex-grow"></select>
                        <button class="glass-button px-4 py-2" id="fightBtn">FIGHT</button>
                    </div>
                    <div class="flex justify-center gap-2">
                        <button class="glass-button py-2 rounded-md w-1/2" id="attackBtn" style="display: none;">ATTACK</button>
                        <button class="glass-button py-2 rounded-md w-1/2" id="castBtn" style="display: none;">CAST</button>
                        <button class="glass-button py-2 rounded-md w-1/2" id="spellstrikeBtn" style="display: none;">SPELLSTRIKE</button>
                    </div>
                    <div id="combat-log-display" class="flex-grow p-2 text-center text-sm"></div>
                </div>`;
            },
            addEventListeners() {
                const combatTab = ui.tabContentCombat;
                combatTab.querySelector('#monsterSelect').addEventListener('change', (e) => this.selectMonster(e.target.value));
                combatTab.querySelector('#fightBtn').addEventListener('click', () => this.fight());
                combatTab.querySelector('#attackBtn').addEventListener('click', () => this.performAction('attack'));
                combatTab.querySelector('#castBtn').addEventListener('click', () => this.performAction('cast'));
                combatTab.querySelector('#spellstrikeBtn').addEventListener('click', () => this.performAction('spellstrike'));
            },
            populateMonsterList(zoneTier) {
                state.game.currentZoneTier = zoneTier;
                const zoneData = GDD.ZONES[zoneTier];
                if (!zoneData) return;
                const monsterTemplates = GDD.MONSTERS[zoneData.biome] || [];
                const monsterSelect = document.getElementById('monsterSelect');
                let optionsHTML = '<option value="">Select a monster...</option>';
                monsterTemplates.forEach(m => optionsHTML += `<option value="${m.id}">${m.name} (T${zoneData.gearTier})</option>`);
                monsterSelect.innerHTML = optionsHTML;
                this.resetCombatSelection();
            },
            selectMonster(monsterId) {
                if (!monsterId) { this.resetCombatSelection(); return; }
                const zoneData = GDD.ZONES[state.game.currentZoneTier];
                const monsterTemplate = GDD.MONSTERS[zoneData.biome].find(m => m.id === monsterId);
                if (!monsterTemplate) return;
                this.currentMonster = {
                    ...monsterTemplate,
                    hp: monsterTemplate.baseHp,
                    maxHp: monsterTemplate.baseHp,
                };
                this.logMessages = [`You are targeting ${this.currentMonster.name}.`];
                this.renderLog();
                this.updateButtons();
            },
            fight() {
                if (!this.currentMonster) {
                    showToast("Please select a monster first.", true);
                    return;
                }
                state.game.combatActive = true;
                this.currentMonster.hp = this.currentMonster.maxHp;
                this.logMessages = [`You engage the ${this.currentMonster.name}!`];
                this.renderLog();
                this.updateButtons();
            },
            performAction(actionType) {
                if (!state.game.combatActive || !this.currentMonster) return;
                const p = state.player;
                const enemy = this.currentMonster;
                // Player's turn
                if (Math.random() * 100 > p.stats.hitChance) {
                    this.logToGame(`You <span class='log-system'>missed</span>!`);
                } else {
                    let damage = 0;
                    let damageSourceStat = 0;
                    switch(p.archetype) {
                        case 'True Fighter': damageSourceStat = p.stats.finalWC; break;
                        case 'True Caster': damageSourceStat = p.stats.finalSC; break;
                        case 'Hybrid': damageSourceStat = (p.stats.finalWC + p.stats.finalSC) * GDD.FORMULAS.HYBRID_MASTERY_EFFICIENCY; break;
                    }
                    damage = (GDD.FORMULAS.PLAYER_DAMAGE_CONSTANT * damageSourceStat) / enemy.baseAC;
                    damage = Math.max(1, damage);
                    let isCrit = Math.random() * 100 < p.stats.critChance;
                    if (isCrit) {
                        damage *= GDD.FORMULAS.CRIT_DAMAGE_MULTIPLIER;
                        this.logToGame(`CRITICAL HIT! You strike ${enemy.name} for <span class="log-player">${damage.toFixed(0)}</span> damage.`);
                    } else {
                        this.logToGame(`You hit ${enemy.name} for <span class="log-player">${damage.toFixed(0)}</span> damage.`);
                    }
                    enemy.hp -= damage;
                }
                // Check for enemy defeat
                if (enemy.hp <= 0) {
                    enemy.hp = 0;
                    this.logToGame(`<span class="log-enemy">${enemy.name} is dead, R.I.P.</span>`);
                    ProfileManager.addXp(enemy.baseXP, p.stats.xpBonus);
                    ProfileManager.addGold(enemy.baseGold);
                    ItemManager.generateAndAwardLoot(GDD.ZONES[state.game.currentZoneTier].gearTier);
                    this.endCombat();
                } else {
                    // Enemy's turn
                    let enemyDamage = Math.max(1, enemy.baseAttack - (p.stats.finalAC * GDD.FORMULAS.MONSTER_DAMAGE_AC_REDUCTION_FACTOR));
                    p.hp -= enemyDamage;
                    this.logToGame(`${enemy.name} hits you for <span class="log-enemy">${enemyDamage.toFixed(0)}</span> damage.`);
                    DataManager.updatePlayer({hp: p.hp});
                }
                if (p.hp <= 0) {
                    p.hp = 0;
                    this.logToGame("You have been defeated!");
                    this.endCombat();
                }
                ProfileManager.updateAllProfileUI();
            },
            endCombat() {
                state.game.combatActive = false;
                this.updateButtons();
            },
            resetCombatSelection() {
                this.currentMonster = null;
                state.game.combatActive = false;
                this.logMessages = ['Select a monster to begin combat.'];
                this.renderLog();
                this.updateButtons();
            },
            updateCombatInfoPanel() {
                const p = state.player;
                if (!p || !p.stats) return;
                const hpPercent = (p.hp / p.stats.maxHp) * 100;
                let healthClass = hpPercent < 20 ? 'text-red-500' : hpPercent < 50 ? 'text-yellow-500' : 'text-green-500';
                
                const createStatHTML = (label, value) => `<span class="text-glow-label">${label}:</span><span class="text-glow-subtle">${value}</span>`;

                document.getElementById('combat-stats-container').innerHTML = `
                    ${createStatHTML('Level', p.level)}
                    ${createStatHTML('Inv/Bags', `${p.inventory.length}/200`)}
                    ${createStatHTML('Health', `<span class="${healthClass}">${Math.ceil(p.hp)} / ${Math.ceil(p.stats.maxHp)}</span>`)}
                    ${createStatHTML('Gem Pouch', `${p.gems.length}/${InventoryManager.MAX_GEMS}`)}
                    ${createStatHTML('Gold', Math.floor(p.gold).toLocaleString())}
                    ${createStatHTML('Last Item', p.lastItemDrop || 'None')}
                    ${createStatHTML('XP', Math.floor(p.xp).toLocaleString())}
                    ${createStatHTML('Last Gem', p.lastGemDrop || 'None')}
                    ${createStatHTML('Next Lvl', Math.floor(p.xpToNextLevel).toLocaleString())}
                    <div class="col-span-4 text-glow-subtle text-center mt-1">Location: ${GDD.ZONES[state.game.currentZoneTier].name}</div>
                `;
            },
            updateButtons() {
                const fightBtn = document.getElementById('fightBtn');
                const attackBtn = document.getElementById('attackBtn');
                const castBtn = document.getElementById('castBtn');
                const spellstrikeBtn = document.getElementById('spellstrikeBtn');

                if(!fightBtn || !attackBtn || !castBtn || !spellstrikeBtn) return;

                fightBtn.disabled = !this.currentMonster || state.game.combatActive;
                const canAct = this.currentMonster && state.game.combatActive;
                attackBtn.style.display = (canAct && state.player.archetype === 'True Fighter') ? 'flex' : 'none';
                castBtn.style.display = (canAct && state.player.archetype === 'True Caster') ? 'flex' : 'none';
                spellstrikeBtn.style.display = (canAct && state.player.archetype === 'Hybrid') ? 'flex' : 'none';
            }
        };

        // --- NEW SANCTUARY & REVIVAL MANAGER ---
        const SanctuaryManager = {
            isPlayerDefeated: false,

            handlePlayerDefeat() {
                if (this.isPlayerDefeated) return; // Prevent multiple triggers
                this.isPlayerDefeated = true;
                state.game.combatActive = false; // Ensure combat ends

                console.log("Player has been defeated.");

                // 1. Apply Penalties as per GDD
                const goldLost = state.player.gold;
                const xpLost = state.player.xp;
                
                state.player.gold = 0;
                state.player.xp = 0; // Reset XP for the current level

                // 2. Log the defeat and penalties
                CombatManager.logToGame("<span class='log-enemy'>You have been defeated!</span>");
                CombatManager.logToGame(`<span class='log-system'>You lost ${Math.floor(goldLost)} gold and ${Math.floor(xpLost)} XP.</span>`);

                // 3. Update the UI to the "Defeated" state
                this.showDefeatedUI();

                // 4. Save the player's defeated state immediately
                DataManager.updatePlayer({ 
                    hp: 0, 
                    gold: 0, 
                    xp: 0 
                });
            },

            revivePlayer() {
                if (!this.isPlayerDefeated) return;

                // 1. Restore HP and remove defeated state
                state.player.hp = state.player.stats.maxHp;
                this.isPlayerDefeated = false;

                // 2. Teleport to the nearest Sanctuary
                // For now, we'll just log it. We will connect this to the World Map later.
                console.log("Player revived at the Sanctuary.");
                showToast("You have been revived at the Sanctuary.", false);
                
                // 3. Hide the defeated UI and restore the game UI
                this.hideDefeatedUI();
                ProfileManager.updateAllProfileUI(); // Refresh all stats

                // 4. Save the revived state
                DataManager.updatePlayer({ hp: state.player.hp });
            },

            showDefeatedUI() {
                // Create a grayscale overlay
                const overlay = document.createElement('div');
                overlay.id = 'defeat-overlay';
                overlay.style.cssText = 'position: fixed; inset: 0; background-color: rgba(0,0,0,0.7); z-index: 1000; display: flex; flex-direction: column; align-items: center; justify-content: center;';
                
                // Create the revival button
                overlay.innerHTML = `
                    <h1 class="font-orbitron text-4xl text-red-500 mb-4">YOU HAVE FALLEN</h1>
                    <p class="text-gray-300 mb-8">Your echo is drawn back to the nearest sanctuary...</p>
                    <button id="revive-btn" class="glass-button w-1/2 max-w-xs py-4 font-bold rounded-md text-lg">Return to Sanctuary</button>
                `;
                
                document.body.appendChild(overlay);

                document.getElementById('revive-btn').addEventListener('click', () => this.revivePlayer());
            },

            hideDefeatedUI() {
                const overlay = document.getElementById('defeat-overlay');
                if (overlay) {
                    overlay.remove();
                }
            }
        };

        // --- WHERE TO MODIFY EXISTING CODE ---
        // You will need to find the `performAction` function inside the `CombatManager`
        // and add one call to the new SanctuaryManager.

        /*
        Inside CombatManager.performAction(), find this block:

        if (p.hp <= 0) {
            p.hp = 0;
            this.logToGame("You have been defeated!");
            this.endCombat();
        }

        REPLACE IT WITH THIS:

        if (p.hp <= 0) {
            p.hp = 0;
            this.endCombat(); // End combat first
            SanctuaryManager.handlePlayerDefeat(); // Then handle the defeat process
        }
        */
   

    const StatsManager = {
            isInitialized: false,
            statMetadata: {
                STR: { name: 'Strength', icon: '💪', description: 'Increases physical damage from Fighter class weapons and contributes to carrying capacity.' },
                DEX: { name: 'Dexterity', icon: '🏹', description: 'Improves accuracy, critical hit chance, and effectiveness of finesse-based weapons.' },
                VIT: { name: 'Vitality', icon: '❤️', description: 'Increases maximum Health Points and improves resistance to physical damage.' },
                NTL: { name: 'Intelligence', icon: '🧠', description: 'Boosts magical damage from Caster class spellbooks and increases maximum Mana.' },
                WIS: { name: 'Wisdom', icon: '🔮', description: 'Enhances magical accuracy, critical spell chance, and resistance to magical effects.' },
                finalWC: { name: 'Weapon Class', icon: '⚔️', description: 'Your total effectiveness with physical weapons, calculated from Strength and equipped items.'
                },
                finalSC: { name: 'Spell Class', icon: '✨', description: 'Your total effectiveness with magic, calculated from Intelligence and equipped spellbooks.' },
                finalAC: { name: 'Armor Class', icon: '🛡️', description: 'Your total damage reduction, calculated from Vitality and equipped armor.' },
                maxHp: { name: 'Health Points', icon: '❤️', description: 'Your life force. If it reaches zero, you are defeated.' },
                hitChance: { name: 'Hit Chance', icon: '🎯', description: 'The probability of successfully landing an attack on an enemy.' },
                critChance: { name: 'Crit Chance', icon: '💥', description: 'The probability of an attack dealing bonus critical damage.' },
            },
            init() {
                if (this.isInitialized) return;
                this.isInitialized = true;
                this.render();
                this.addEventListeners();
            },
            render() {
                const statsContainer = ui.tabContentStats;
                if (!statsContainer || !state.player) return;
                const p = state.player;
                const canUpgrade = p.attributePoints >= GDD.FORMULAS.AP_PER_LEVEL;

                const createStatLine = (attrKey, value, isUpgradable = false) => {
                    const meta = this.statMetadata[attrKey] || { name: attrKey, icon: '?', description: 'No info available.' };
                    const upgradeButton = isUpgradable ? `<button class="attr-btn" data-attr="${attrKey}" ${!canUpgrade ? 'disabled' : ''}>+</button>` : '';
                    const infoButton = `<button class="info-btn" data-title="${meta.name}" data-description="${meta.description}">i</button>`;
                    return `
                    <div class="stat-line">
                        <span class="stat-icon">${meta.icon}</span>
                        <span class="stat-name text-glow-subtle">${meta.name}</span>
                        <span class="stat-value text-glow-subtle" data-stat-value="${attrKey}">${value}</span>
                        ${upgradeButton}
                        ${infoButton}
                    </div>`;
                };

                const createHpLine = () => {
                    const meta = this.statMetadata.maxHp;
                    const hpPercent = (p.hp / p.stats.maxHp) * 100;
                    return `
                    <div class="stat-line">
                        <span class="stat-icon">${meta.icon}</span>
                        <span class="stat-name text-glow-subtle">${meta.name}</span>
                        <div class="flex-grow flex items-center gap-2">
                            <div class="progress-bar-track h-3 flex-grow"><div class="progress-bar-fill h-full" style="width: ${hpPercent}%; background-color: var(--hp-color);"></div></div>
                            <span class="stat-value text-glow-subtle">${Math.ceil(p.hp)} / ${Math.ceil(p.stats.maxHp)}</span>
                        </div>
                        <button class="info-btn" data-title="${meta.name}" data-description="${meta.description}">i</button>
                    </div>`;
                };

                statsContainer.innerHTML = `
                <div id="stats-container" class="space-y-3">
                    <div class="stat-accordion-item open">
                        <button class="stat-accordion-header">
                            <h3 class="text-glow-subtle font-orbitron">Secondary Attributes</h3>
                            <svg class="accordion-arrow w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>
                        </button>
                        <div class="stat-accordion-content">
                            ${createStatLine('STR', Math.round(p.baseStats.STR), true)}
                            ${createStatLine('DEX', Math.round(p.baseStats.DEX), true)}
                            ${createStatLine('VIT', Math.round(p.baseStats.VIT), true)}
                            ${createStatLine('NTL', Math.round(p.baseStats.NTL), true)}
                            ${createStatLine('WIS', Math.round(p.baseStats.WIS), true)}
                            <div class="stat-line mt-2">
                                <span class="stat-icon">💎</span>
                                <span class="stat-name text-glow-subtle">Unspent Points</span>
                                <span id="unspent-points-value" class="stat-value text-glow-label">${p.attributePoints || 0}</span>
                            </div>
                        </div>
                    </div>
                    <div class="stat-accordion-item">
                        <button class="stat-accordion-header">
                            <h3 class="text-glow-subtle font-orbitron">Primary Combat Stats</h3>
                            <svg class="accordion-arrow w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>
                        </button>
                        <div class="stat-accordion-content">
                            ${createStatLine('finalWC', p.stats.finalWC.toFixed(2))}
                            ${createStatLine('finalSC', p.stats.finalSC.toFixed(2))}
                            ${createStatLine('finalAC', p.stats.finalAC.toFixed(2))}
                        </div>
                    </div>
                    <div class="stat-accordion-item">
                        <button class="stat-accordion-header">
                            <h3 class="text-glow-subtle font-orbitron">Derived Stats</h3>
                            <svg class="accordion-arrow w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>
                        </button>
                        <div class="stat-accordion-content">
                            ${createHpLine()}
                            ${createStatLine('hitChance', `${p.stats.hitChance.toFixed(2)}%`)}
                            ${createStatLine('critChance', `${p.stats.critChance.toFixed(2)}%`)}
                        </div>
                    </div>
                </div>`;
            },
            addEventListeners() {
                const statsContainer = ui.tabContentStats;
                statsContainer.addEventListener('click', (e) => {
                    const header = e.target.closest('.stat-accordion-header');
                    const attrBtn = e.target.closest('.attr-btn');
                    const infoBtn = e.target.closest('.info-btn');
                    if (header) {
                        header.parentElement.classList.toggle('open');
                    } else if (attrBtn) {
                        ProfileManager.spendAttributePoint(attrBtn.dataset.attr);
                    } else if (infoBtn) {
                        this.showStatInfo(infoBtn.dataset.title, infoBtn.dataset.description);
                    }
                });
                document.getElementById('stat-info-backdrop').addEventListener('click', () => this.hideStatInfo());
            },
            showStatInfo(title, description) {
                const modal = document.getElementById('stat-info-modal');
                modal.querySelector('#stat-info-title').textContent = title;
                modal.querySelector('#stat-info-description').textContent = description;
                modal.style.display = 'flex';
            },
            hideStatInfo() {
                document.getElementById('stat-info-modal').style.display = 'none';
            }
        };

        const InventoryManager = {
            isInitialized: false,
            MAX_GEMS: 200,
            filterState: { category: 'All', subType: 'All', tier: 'All', quality: 'All', sortBy: 'tier', order: 'desc' },
            inventoryBags: {
                'Weapon Chest': ['Weapons'],
                'Bag of Gear': ['Armor'],
                'Jewelry Box': ['Amulet', 'Ring'],
                'Spell Satchel': ['Spells'],
            },
            init() {
                if (this.isInitialized) return;
                this.isInitialized = true;
                this.renderInventoryTab();
                this.addEventListeners();
                this.populateFilterOptions();
                this.updateAllViews();
            },
            renderInventoryTab() {
                const inventoryContainer = ui.tabContentInventory;
                let bagsHTML = "";
                for (const bagName in this.inventoryBags) {
                    bagsHTML += `
                    <div class="stat-accordion-item open" data-bag-container="${bagName}">
                        <button class="stat-accordion-header">
                            <h3 class="text-glow-subtle font-orbitron">${bagName} <span id="inventory-${bagName.replace(/\s+/g, '-')}-count" class="text-xs text-gray-400 font-sans"></span></h3>
                            <svg class="accordion-arrow w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>
                        </button>
                        <div class="stat-accordion-content !p-2">
                            <div class="inventory-grid" data-bag-name="${bagName}"></div>
                        </div>
                    </div>`;
                }
                inventoryContainer.innerHTML = `
                <div id="inventory-sort-container" class="mb-2">
                    <div class="stat-accordion-item open">
                        <button class="stat-accordion-header">
                            <h3 class="text-glow-subtle font-orbitron"><svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4h13M3 8h9M3 12h9m-9 4h6"></path></svg>Sort & Filter</h3>
                            <svg class="accordion-arrow w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>
                        </button>
                        <div class="stat-accordion-content !p-2">
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-2">
                                <div><label class="text-xs text-gray-400">Category</label><select id="inventory-filter-category-select" class="editor-input !w-full !text-xs"></select></div>
                                <div><label class="text-xs text-gray-400">Sub-Type</label><select id="inventory-filter-subtype-select" class="editor-input !w-full !text-xs"></select></div>
                                <div><label class="text-xs text-gray-400">Tier</label><select id="inventory-filter-tier-select" class="editor-input !w-full !text-xs"></select></div>
                                <div><label class="text-xs text-gray-400">Quality</label><select id="inventory-filter-quality-select" class="editor-input !w-full !text-xs"></select></div>
                            </div>
                            <div class="grid grid-cols-2 gap-2 mt-2 border-t border-gray-700 pt-2">
                                <div><label class="text-xs text-gray-400">Sort By</label><select id="inventory-sort-by-select" class="editor-input !w-full !text-xs"><option value="tier">Tier</option><option value="name">Name</option><option value="type">Type</option></select></div>
                                <div><label class="text-xs text-gray-400">Order</label><select id="inventory-sort-order-select" class="editor-input !w-full !text-xs"><option value="desc">Descending</option><option value="asc">Ascending</option></select></div>
                            </div>
                        </div>
                    </div>
                </div>
                ${bagsHTML}
                <div class="stat-accordion-item open">
                    <button class="stat-accordion-header">
                        <h3 class="text-glow-subtle font-orbitron">Gem Pouch <span id="inventory-gem-pouch-count" class="text-xs text-gray-400 font-sans"></span></h3>
                        <svg class="accordion-arrow w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>
                    </button>
                    <div class="stat-accordion-content !p-2">
                        <div class="gem-pouch-grid"></div>
                    </div>
                </div>`;
            },
            addEventListeners() {
                const inventoryContainer = ui.tabContentInventory;
                inventoryContainer.addEventListener('click', e => {
                    const slot = e.target.closest('.inventory-slot');
                    const gemItem = e.target.closest('.gem-item');
                    const header = e.target.closest('.stat-accordion-header');
                    if (slot?.dataset.instanceId) this.showItemActionModal(slot.dataset.instanceId, null);
                    else if (gemItem?.dataset.gemId) this.showItemActionModal(null, gemItem.dataset.gemId);
                    else if (header) header.parentElement.classList.toggle('open');
                });
                inventoryContainer.addEventListener('change', e => {
                    const targetId = e.target.id;
                    if (targetId.startsWith('inventory-filter-') || targetId.startsWith('inventory-sort-')) {
                        this.filterState.category = document.getElementById('inventory-filter-category-select').value;
                        this.filterState.subType = document.getElementById('inventory-filter-subtype-select').value;
                        this.filterState.tier = document.getElementById('inventory-filter-tier-select').value;
                        this.filterState.quality = document.getElementById('inventory-filter-quality-select').value;
                        this.filterState.sortBy = document.getElementById('inventory-sort-by-select').value;
                        this.filterState.order = document.getElementById('inventory-sort-order-select').value;
                        if (targetId === 'inventory-filter-category-select') {
                            this.populateSubTypeFilter();
                            this.filterState.subType = 'All';
                            document.getElementById('inventory-filter-subtype-select').value = 'All';
                        }
                        this.renderInventoryBags();
                    }
                });
                document.getElementById('item-action-modal-backdrop').addEventListener('click', () => this.hideItemActionModal());
            },
            populateFilterOptions() {
                document.getElementById('inventory-filter-category-select').innerHTML = ['All', ...Object.keys(this.inventoryBags)].map(c => `<option value="${c}">${c}</option>`).join("");
                document.getElementById('inventory-filter-tier-select').innerHTML = '<option value="All">All Tiers</option>' + Array.from({length: 20}, (_, i) => `<option value="${i+1}">Tier ${i+1}</option>`).join("");
                document.getElementById('inventory-filter-quality-select').innerHTML = ['All', 'Dropper', 'Shadow', 'Echo'].map(q => `<option value="${q}">${q}</option>`).join("");
                this.populateSubTypeFilter();
            },
            populateSubTypeFilter() {
                const category = document.getElementById('inventory-filter-category-select').value;
                const subTypeSelect = document.getElementById('inventory-filter-subtype-select');
                let subTypes = new Set();
                const itemsToScan = GDD.ITEMS.baseItemTemplates.filter(item => {
                    if (category === 'All') return true;
                    return this.inventoryBags[category]?.includes(item.type);
                });
                itemsToScan.forEach(item => subTypes.add(item.subType || item.type));
                subTypeSelect.innerHTML = ['All', ...Array.from(subTypes).sort()].map(s => `<option value="${s}">${s}</option>`).join("");
            },
            renderInventoryBags() {
                const equippedIds = Object.values(state.player.equipment).filter(Boolean);
                let unequippedItems = state.player.inventory.filter(item => !equippedIds.includes(item.instanceId));
                const { category, subType, tier, quality} = this.filterState;
                const filteredItems = unequippedItems.filter(item => {
                    const base = GDD.ITEMS.baseItemTemplates.find(b => b.id === item.baseItemId);
                    if (!base) return false;
                    if (category !== 'All' && !this.inventoryBags[category]?.includes(base.type)) return false;
                    if (subType !== 'All' && (base.subType || base.type) !== subType) return false;
                    if (tier !== 'All' && item.tier.toString() !== tier) return false;
                    if (quality !== 'All' && item.type !== quality) return false;
                    return true;
                });
                filteredItems.sort((a, b) => {
                    const baseA = GDD.ITEMS.baseItemTemplates.find(item => item.id === a.baseItemId);
                    const baseB = GDD.ITEMS.baseItemTemplates.find(item => item.id === b.baseItemId);
                    let compareA = (this.filterState.sortBy === 'name') ? baseA.name : (this.filterState.sortBy === 'type' ? baseA.type : a.tier);
                    let compareB = (this.filterState.sortBy === 'name') ? baseB.name : (this.filterState.sortBy === 'type' ? baseB.type : b.tier);
                    if (compareA < compareB) return this.filterState.order === 'asc' ? -1 : 1;
                    if (compareA > compareB) return this.filterState.order === 'asc' ? 1 : -1;
                    return 0;
                });
                document.querySelectorAll('#tab-content-inventory .inventory-grid').forEach(grid => grid.innerHTML = "");
                filteredItems.forEach(item => {
                    const base = GDD.ITEMS.baseItemTemplates.find(b => b.id === item.baseItemId);
                    for (const bagName in this.inventoryBags) {
                        if (this.inventoryBags[bagName].includes(base.type)) {
                            const grid = document.querySelector(`#tab-content-inventory .inventory-grid[data-bag-name="${bagName}"]`);
                            if (grid) {
                                let overlaysHTML = this.generateGemOverlaysHTML(item);
                                grid.innerHTML += `
                                <div class="inventory-slot" data-instance-id="${item.instanceId}">
                                    ${overlaysHTML}
                                    <img src="${base.imageUrl}" onerror="this.onerror=null;this.src='https://placehold.co/60x60/1f2937/ffffff?text=ERR';">
                                    <span class="item-tier-label">T${item.tier}</span>
                                </div>`;
                            }
                            break;
                        }
                    }
                });
                this.updateCounts();
            },
            updateAllViews() {
                this.renderInventoryBags();
                this.renderGemPouch();
                this.updateCounts();
            },
            updateCounts() {
                const equippedIds = Object.values(state.player.equipment).filter(Boolean);
                const unequippedItems = state.player.inventory.filter(item => !equippedIds.includes(item.instanceId));
                for (const bagName in this.inventoryBags) {
                    const count = unequippedItems.filter(item => {
                        const baseItem = GDD.ITEMS.baseItemTemplates.find(b => b.id === item.baseItemId);
                        return baseItem && this.inventoryBags[bagName].includes(baseItem.type);
                    }).length;
                    document.getElementById(`inventory-${bagName.replace(/\s+/g, '-')}-count`).textContent = `(${count})`;
                }
                document.getElementById('inventory-gem-pouch-count').textContent = `(${state.player.gems.length}/${this.MAX_GEMS})`;
            },
            renderGemPouch() {
                const grid = document.querySelector('#tab-content-inventory .gem-pouch-grid');
                if (!grid) return;
                grid.innerHTML = state.player.gems.map(gemInfo => {
                    const gem = GDD.GEMS[gemInfo.id];
                    return `
                    <div class="gem-item" data-gem-id="${gemInfo.id}"><img src="${gem.imageUrl}" class="w-10 h-10" onerror="this.onerror=null;this.src='https://placehold.co/40x40/1f2937/ffffff?text=ERR';"><span class="item-label text-glow-subtle">${gem.abbreviation}${gemInfo.grade}</span></div>`;
                }).join("");
            },
            showItemActionModal(instanceId, gemId) {
                const modalBody = document.getElementById('item-action-modal-body');
                let contentHTML = "", actionButtonHTML = "", actionHandler = null;
                if (instanceId) {
                    const item = state.player.inventory.find(i => i.instanceId === instanceId);
                    if (!item) return;
                    const baseItem = GDD.ITEMS.baseItemTemplates.find(b => b.id === item.baseItemId);
                    const isEquipped = Object.values(state.player.equipment).includes(instanceId);
                    let gemListHTML = item.socketedGems?.filter(g => g).length > 0 ? `<div class="item-gem-list">${item.socketedGems.map(gemInfo => {
                        if (!gemInfo) return "";
                        const gemData = GDD.GEMS[gemInfo.id];
                        return `<div class="item-gem-entry"><span class="item-gem-name">${gemData.abbreviation}${gemInfo.grade}</span><span class="item-gem-effect">${this.getGemEffectValueText(gemInfo, gemData)}</span></div>`;
                    }).join("")}</div>` : "";
                    contentHTML = `<div class="item-name text-glow-subtle">${baseItem.name}</div><div class="item-type">Tier ${item.tier} ${baseItem.type}</div>${gemListHTML}`;
                    actionButtonHTML = `<button id="item-action-button" class="glass-button w-full py-2 rounded-md mt-4">${isEquipped ? 'Unequip' : 'Equip'}</button>`;
                    actionHandler = () => isEquipped ? this.unequipItem(instanceId) : this.equipItem(instanceId);
                } else if (gemId) {
                    const gemInfo = state.player.gems.find(g => g.id === gemId);
                    if (!gemInfo) return;
                    const gemData = GDD.GEMS[gemId];
                    contentHTML = `<div class="item-name text-glow-subtle">${gemData.name}</div><div class="item-type">Grade ${gemInfo.grade} Gem</div><div class="item-stat"><span class="item-stat-label">${gemData.effect}: </span><span class="item-stat-value text-glow-label">${this.getGemEffectValueText(gemInfo, gemData)}</span></div>`;
                }
                modalBody.innerHTML = contentHTML + actionButtonHTML;
                document.getElementById('item-action-modal-content').style.display = 'block';
                document.getElementById('item-action-modal-backdrop').style.display = 'block';
                const actionButton = document.getElementById('item-action-button');
                if (actionButton && actionHandler) actionButton.addEventListener('click', actionHandler, { once: true });
            },
            getGemEffectValueText(gemInfo, gemData) {
                let effectiveGrade = Array.from({length: GDD.GemGradeUnlockLevels.length}, (_, i) => state.player.level >= GDD.GemGradeUnlockLevels[i] ? i + 1 : 0).filter(Boolean).pop() || 1;
                const gradeIndex = Math.min(gemInfo.grade, effectiveGrade) - 1;
                if (gradeIndex < 0 || !gemData.values) return 'N/A';
                return `+${Array.isArray(gemData.values) ? gemData.values[gradeIndex] : gemData.values.sc?.[gradeIndex] || gemData.values.wc?.[gradeIndex]}%`;
            },
            hideItemActionModal() {
                document.getElementById('item-action-modal-content').style.display = 'none';
                document.getElementById('item-action-modal-backdrop').style.display = 'none';
            },
            equipItem(instanceId) {
                const item = state.player.inventory.find(i => i.instanceId === instanceId);
                const baseItem = GDD.ITEMS.baseItemTemplates.find(b => b.id === item.baseItemId);
                const slotType = baseItem.type;
                let targetSlotName = GDD.equipmentSlotConfig.find(slot => slot.type === slotType && !state.player.equipment[slot.name])?.name;
                if (!targetSlotName) {
                    targetSlotName = GDD.equipmentSlotConfig.find(slot => slot.type === slotType)?.name;
                }
                if (!targetSlotName) {
                    showToast(`No available slot for ${slotType}.`, true);
                    return;
                }
                if (state.player.equipment[targetSlotName]) {
                    this.unequipItem(state.player.equipment[targetSlotName], false);
                }
                state.player.equipment[targetSlotName] = instanceId;
                this.hideItemActionModal();
                this.updateAllViews();
                if (EquipmentManager.isInitialized) EquipmentManager.renderEquipmentView();
                ProfileManager.calculateAllStats();
                showToast(`${baseItem.name} equipped.`, false);
                DataManager.updatePlayer({ equipment: state.player.equipment });
            },
            unequipItem(instanceId, showModalUpdate = true) {
                const slotName = Object.keys(state.player.equipment).find(key => state.player.equipment[key] === instanceId);
                if (!slotName) return;
                const item = state.player.inventory.find(i => i.instanceId === instanceId);
                const baseItem = GDD.ITEMS.baseItemTemplates.find(b => b.id === item.baseItemId);
                state.player.equipment[slotName] = null;
                this.hideItemActionModal();
                if (showModalUpdate) {
                    this.updateAllViews();
                    if (EquipmentManager.isInitialized) EquipmentManager.renderEquipmentView();
                }
                ProfileManager.calculateAllStats();
                showToast(`${baseItem.name} unequipped.`, false);
                DataManager.updatePlayer({ equipment: state.player.equipment });
            },
            generateGemOverlaysHTML(item) {
                let overlaysHTML = '';
                if (item.socketedGems && item.socketedGems.length > 0) {
                    overlaysHTML += '<div class="gem-overlays-container">';
                    const gem1 = item.socketedGems[0];
                    const gem2 = item.socketedGems[1];

                    if (gem1) {
                        const gemData1 = GDD.GEMS[gem1.id];
                        overlaysHTML += `<div class="gem-overlay ${gemData1.type.toLowerCase()}">${gemData1.abbreviation}${gem1.grade}</div>`;
                    }

                    if (!gem1 && gem2) {
                        overlaysHTML += '<div></div>'; // Spacer
                    }

                    if (gem2) {
                        const gemData2 = GDD.GEMS[gem2.id];
                        overlaysHTML += `<div class="gem-overlay ${gemData2.type.toLowerCase()}">${gemData2.abbreviation}${gem2.grade}</div>`;
                    }
                    overlaysHTML += '</div>';
                }
                return overlaysHTML;
            }
        };

        const EquipmentManager = {
            isInitialized: false,
            init() {
                if(this.isInitialized) return;
                this.isInitialized = true;
                this.renderEquipmentView();
                this.addEventListeners();
            },
            renderEquipmentView() {
                const equipmentContainer = ui.tabContentEquipment;
                if (!equipmentContainer) return;
                const slotsHTML = GDD.equipmentSlotConfig.map(slot => {
                    const instanceId = state.player.equipment[slot.name];
                    const item = state.player.inventory.find(i => i.instanceId === instanceId);
                    let contentHTML = '<span class="text-xs text-gray-500">Empty</span>';
                    if (item) {
                        const base = GDD.ITEMS.baseItemTemplates.find(b => b.id === item.baseItemId);
                        let overlaysHTML = InventoryManager.generateGemOverlaysHTML(item);
                        contentHTML = `
                        ${overlaysHTML}
                        <img src="${base.imageUrl}" class="h-12 w-12 object-contain" onerror="this.onerror=null;this.src='https://placehold.co/48x48/1f2937/ffffff?text=ERR';">
                        <span class="item-tier-label">T${item.tier}</span>`;
                    }
                    return`
                    <div class="equipment-slot-wrapper">
                        <div class="equipment-slot-title font-orbitron text-glow-subtle"><span>${slot.name}</span></div>
                        <div class="equipment-slot-content" data-slot-name="${slot.name}" data-instance-id="${instanceId || ""}">${contentHTML}</div>
                    </div>`;
                }).join("");
                equipmentContainer.innerHTML = `<div class="equipment-grid">${slotsHTML}</div>`;
            },
            addEventListeners() {
                const equipmentContainer = ui.tabContentEquipment;
                equipmentContainer.addEventListener('click', e => {
                    const slot = e.target.closest('.equipment-slot-content');
                    if (slot && slot.dataset.instanceId) {
                        InventoryManager.showItemActionModal(slot.dataset.instanceId, null);
                    }
                });
            },
        };

        const InfusionManager = {
            init() {
                this.addEventListeners();
                this.switchTab('socket', true); // Initial render
            },

            switchTab(tabName, isPrimary) {
                if (isPrimary) {
                    state.ui.activeTab = tabName;
                    document.querySelectorAll('#infusion-container .primary-tab-button, #infusion-container .primary-panel').forEach(el => el.classList.remove('active'));
                    document.querySelector(`#infusion-container .primary-tab-button[data-tab="${tabName}"]`).classList.add('active');
                    document.getElementById(`infusion-${tabName}-panel`).classList.add('active');
                } else { // Secondary tab switch (Visual/Text)
                    state.ui.activeSocketView = tabName;
                    document.querySelectorAll('#infusion-container .secondary-tab-button, #infusion-container .secondary-panel').forEach(el => el.classList.remove('active'));
                    document.querySelector(`#infusion-container .secondary-tab-button[data-view="${tabName}"]`).classList.add('active');
                    document.getElementById(`socket-${tabName}-view`).classList.add('active');
                }
                
                state.ui.selectedGemForSocketing = null; // Clear selection on tab switch
                this.renderAll();
            },
            
            addEventListeners() {
                const container = document.getElementById('infusion-container');
                const infoModalBackdrop = document.getElementById('info-modal-backdrop');

                container.addEventListener('click', e => {
                    const primaryTabBtn = e.target.closest('.primary-tab-button');
                    const secondaryTabBtn = e.target.closest('.secondary-tab-button');
                    const gemItem = e.target.closest('.gem-item');
                    const inventoryItem = e.target.closest('.inventory-slot');
                    const itemFilterBtn = e.target.closest('.item-filter-btn');
                    const gemFilterBtn = e.target.closest('.gem-filter-btn');
                    const infoBtn = e.target.closest('#info-button');
                    const textSocketBtn = e.target.closest('#text-socket-btn');

                    if (primaryTabBtn) this.switchTab(primaryTabBtn.dataset.tab, true);
                    if (secondaryTabBtn) this.switchTab(secondaryTabBtn.dataset.view, false);
                    if (gemItem) this.showGemTooltip(gemItem.dataset.gemid, gemItem.dataset.grade);
                    if (itemFilterBtn) this.handleItemFilterClick(itemFilterBtn);
                    if (gemFilterBtn) this.handleGemFilterClick(gemFilterBtn);
                    if (infoBtn) this.showInfoModal();
                    if (textSocketBtn) this.handleTextSocket();
                    
                    if (inventoryItem) {
                        if (state.ui.activeTab === 'socket') {
                            this.handleSocketItemClick(inventoryItem.dataset.instanceId);
                        } else {
                            this.showUnsocketChoiceModal(inventoryItem.dataset.instanceId);
                        }
                    }
                });
                
                container.addEventListener('change', e => {
                    const select = e.target.closest('.item-tier-filter');
                    if (select) {
                        state.ui.itemFilter.tier = select.value;
                        this.renderAll();
                    }
                });

                infoModalBackdrop.addEventListener('click', (e) => {
                    if (e.target.id === 'info-modal-backdrop' || e.target.closest('#info-modal-close-btn')) {
                        this.hideInfoModal();
                    }
                });
            },

            showInfoModal() {
                document.getElementById('info-modal-backdrop').style.display = 'flex';
                document.getElementById('info-modal-content').style.display = 'block';
            },

            hideInfoModal() {
                document.getElementById('info-modal-backdrop').style.display = 'none';
                document.getElementById('info-modal-content').style.display = 'none';
            },

            renderAll() {
                this.renderGemFilterBars();
                this.renderGemPouch();
                this.renderItemFilterBar('socket');
                this.renderItemFilterBar('unsocket');
                this.renderFilteredInventory('socket');
                this.renderFilteredInventory('unsocket');
                this.populateTextViewDropdowns();
                this.renderTextSocketedItems();
            },
            
            renderGemFilterBars() {
                const { type, grade } = state.ui.gemFilter;
                const typeBar = document.getElementById('gem-type-filter-bar');
                const gradeBar = document.getElementById('gem-grade-filter-bar');
                if(!typeBar || !gradeBar) return;

                const gemTypes = ['All', ...new Set(Object.values(GDD.GEMS).map(g => g.type))];
                const gemGrades = ['All', ...Array.from({length: 9}, (_, i) => `${i+1}`)];

                typeBar.innerHTML = gemTypes.map(t => `<button class="filter-btn gem-filter-btn ${t === type ? 'active' : ''}" data-filter-type="type" data-value="${t}">${t}</button>`).join('');
                gradeBar.innerHTML = gemGrades.map(g => `<button class="filter-btn gem-filter-btn ${g === grade ? 'active' : ''}" data-filter-type="grade" data-value="${g}">${g === 'All' ? 'All' : `G${g}`}</button>`).join('');
            },

            handleGemFilterClick(btn) {
                const { filterType, value } = btn.dataset;
                state.ui.gemFilter[filterType] = value;
                this.renderGemFilterBars();
                this.renderGemPouch();
            },

            renderItemFilterBar(view) {
                const filterBar = document.getElementById(`item-filter-bar-${view}`);
                if (!filterBar) return;

                const { category, subType, tier } = state.ui.itemFilter;
                const categories = ['All', ...new Set(GDD.ITEMS.baseItemTemplates.map(i => i.type))];
                let subTypes = ['All'];
                if (category !== 'All') {
                    subTypes.push(...new Set(GDD.ITEMS.baseItemTemplates.filter(i => i.type === category).map(i => i.subType).filter(Boolean)));
                }
                const tiers = ['All', ...Array.from({length: GDD.MAX_TIER}, (_, i) => `${i+1}`)];

                const catButtons = categories.map(c => `<button class="filter-btn item-filter-btn ${c === category ? 'active' : ''}" data-filter-type="category" data-value="${c}">${c}</button>`).join('');
                const subTypeButtons = subTypes.length > 1 ? subTypes.map(s => `<button class="filter-btn item-filter-btn ${s === subType ? 'active' : ''}" data-filter-type="subType" data-value="${s}">${s}</button>`).join('') : '';
                const tierDropdown = `<select class="editor-input item-tier-filter !w-auto !text-xs">${tiers.map(t => `<option value="${t}" ${t === tier ? 'selected' : ''}>${t === 'All' ? 'All Tiers' : `T${t}`}</option>`).join('')}</select>`;
                
                filterBar.innerHTML = `
                    <div class="filter-group">${catButtons}</div>
                    ${subTypes.length > 1 ? `<div class="filter-group">${subTypeButtons}</div>` : ''}
                    <div class="filter-group">${tierDropdown}</div>
                `;
            },

            handleItemFilterClick(btn) {
                const { filterType, value } = btn.dataset;
                if (filterType === 'category') {
                    state.ui.itemFilter.category = value;
                    state.ui.itemFilter.subType = 'All';
                } else {
                    state.ui.itemFilter.subType = value;
                }
                this.renderAll();
            },

            renderFilteredInventory(view) {
                const gridElement = document.getElementById(`item-inventory-grid-${view}`);
                if (!gridElement) return;

                const { category, subType, tier } = state.ui.itemFilter;
                
                const items = state.player.inventory.filter(item => {
                    const base = GDD.ITEMS.baseItemTemplates.find(b => b.id === item.baseItemId);
                    if (!base) return false;

                    if (view === 'socket' && item.socketedGems.length >= base.sockets) return false;
                    if (view === 'unsocket' && item.socketedGems.length === 0) return false;
                    if (category !== 'All' && base.type !== category) return false;
                    if (subType !== 'All' && base.subType !== subType) return false;
                    if (tier !== 'All' && item.tier.toString() !== tier) return false;
                    
                    return true;
                });
                
                gridElement.innerHTML = items.map(item => {
                    const base = GDD.ITEMS.baseItemTemplates.find(b => b.id === item.baseItemId);
                    const gemCount = item.socketedGems.filter(Boolean).length;
                    let glowClass = '';
                    if (gemCount > 0) {
                        glowClass = gemCount === base.sockets ? 'glow-full' : 'glow-partial';
                    }
                    
                    let overlaysHTML = InventoryManager.generateGemOverlaysHTML(item);

                    return `
                    <div class="inventory-slot" data-instance-id="${item.instanceId}">
                        <div class="item-glow-container ${glowClass}"></div>
                        ${overlaysHTML}
                        <img src="${base.imageUrl}" alt="${base.name}" onerror="this.onerror=null;this.src='https://placehold.co/72x72/1f2937/ffffff?text=ERR';">
                        <span class="item-tier-label">T${item.tier}</span>
                    </div>`;
                }).join("");
            },

            renderGemPouch() {
                const gemGrid = document.getElementById('infusion-gem-pouch-grid');
                if (!gemGrid) return;
                const { type, grade } = state.ui.gemFilter;
                const filteredGems = state.player.gems.filter(gemInfo =>
                    (grade === 'All' || gemInfo.grade.toString() === grade) &&
                    (type === 'All' || GDD.GEMS[gemInfo.id].type === type)
                );
                gemGrid.innerHTML = filteredGems.map(gemInfo => {
                    const gem = GDD.GEMS[gemInfo.id];
                    const isSelected = state.ui.selectedGemForSocketing?.id === gemInfo.id && state.ui.selectedGemForSocketing?.grade === gemInfo.grade;
                    return `
                    <div class="gem-item gem-type-${gem.type} ${isSelected ? 'selected-for-socket' : ''}" data-gemid="${gemInfo.id}" data-grade="${gemInfo.grade}">
                        <img src="${gem.imageUrl}" alt="${gem.name}" class="w-10 h-10" onerror="this.onerror=null; this.src='https://placehold.co/40x40/1f2937/ffffff?text=ERR';">
                        <span class="item-label">${gem.abbreviation}${gemInfo.grade}</span>
                    </div>`;
                }).join("");
            },
            
            populateTextViewDropdowns() {
                const itemSelect = document.getElementById('text-item-select');
                const gemSelect = document.getElementById('text-gem-select');
                if (!itemSelect || !gemSelect) return;

                const availableItems = state.player.inventory.filter(item => {
                    const base = GDD.ITEMS.baseItemTemplates.find(b => b.id === item.baseItemId);
                    return base && item.socketedGems.length < base.sockets;
                });
                
                if (availableItems.length > 0) {
                    itemSelect.innerHTML = availableItems.map(item => {
                        const base = GDD.ITEMS.baseItemTemplates.find(b => b.id === item.baseItemId);
                        return `<option value="${item.instanceId}">(SD)${base.name}T${item.tier}</option>`;
                    }).join('');
                } else {
                    itemSelect.innerHTML = `<option value="">No Available Items</option>`;
                }

                if (state.player.gems.length > 0) {
                    gemSelect.innerHTML = state.player.gems.map(gem => {
                        const base = GDD.GEMS[gem.id];
                        return `<option value="${gem.id}:${gem.grade}">${base.name}${gem.grade}</option>`;
                    }).join('');
                } else {
                    gemSelect.innerHTML = `<option value="">No Available Gems</option>`;
                }
            },

            renderTextSocketedItems() {
                const display = document.getElementById('text-socketed-items-display');
                if (!display) return;
                const socketedItems = state.player.inventory.filter(item => item.socketedGems.length > 0);

                if (socketedItems.length === 0) {
                    display.innerHTML = '<p>No items with gems socketed.</p>';
                    return;
                }

                display.innerHTML = socketedItems.map(item => {
                    const base = GDD.ITEMS.baseItemTemplates.find(b => b.id === item.baseItemId);
                    const gemStrings = item.socketedGems.map(g => `[${GDD.GEMS[g.id].abbreviation}${g.grade}]`).join('');
                    return `<div>(SD)${base.name}T${item.tier}${gemStrings}</div>`;
                }).join('');
            },

            handleTextSocket() {
                const itemSelect = document.getElementById('text-item-select');
                const gemSelect = document.getElementById('text-gem-select');

                if (!itemSelect.value || !gemSelect.value) {
                    showToast("Please select both an item and a gem.", true);
                    return;
                }

                const instanceId = itemSelect.value;
                const [gemId, gemGradeStr] = gemSelect.value.split(':');
                const gemGrade = parseInt(gemGradeStr);

                const item = state.player.inventory.find(i => i.instanceId === instanceId);
                const gemIndexInPouch = state.player.gems.findIndex(g => g.id === gemId && g.grade === gemGrade);

                if (!item || gemIndexInPouch === -1) {
                    showToast("Error: Selected item or gem not found.", true);
                    return;
                }

                const gemToSocket = state.player.gems[gemIndexInPouch];
                
                state.player.gems.splice(gemIndexInPouch, 1);
                item.socketedGems.push(gemToSocket);
                
                showToast("Item infused successfully via text view!", false);
                this.renderAll();
                ProfileManager.calculateAllStats();
                DataManager.updatePlayer({inventory: state.player.inventory, gems: state.player.gems});
            },

            showGemTooltip(gemId, grade) {
                const gem = GDD.GEMS[gemId];
                const modalContent = document.getElementById('gem-tooltip-content');
                
                modalContent.innerHTML = `
                    <div class="text-center">
                        <div class="gem-item gem-type-${gem.type} !w-20 !h-20 mx-auto !border-4">
                           <img src="${gem.imageUrl}" class="mx-auto w-16 h-16 object-contain" onerror="this.onerror=null;this.src='https://placehold.co/64x64/1f2937/ffffff?text=ERR';">
                        </div>
                        <h3 class="font-orbitron text-lg mt-2">${gem.name} (Grade ${grade})</h3>
                        <p class="text-gray-300 mt-1">${gem.stats}</p>
                        <div class="flex gap-2 mt-4">
                            <button id="gem-tooltip-socket-btn" class="modal-button confirm">Select for Socketing</button>
                            <button id="gem-tooltip-cancel-btn" class="modal-button">Cancel</button>
                        </div>
                    </div>`;

                document.getElementById('gem-tooltip-backdrop').style.display = 'flex';
                modalContent.style.display = 'block';

                modalContent.querySelector('#gem-tooltip-socket-btn').onclick = () => {
                    state.ui.selectedGemForSocketing = { id: gemId, grade: parseInt(grade) };
                    this.renderGemPouch();
                    this.hideGemTooltip();
                    showToast(`${gem.name} selected. Choose an item to infuse.`, false);
                };
                modalContent.querySelector('#gem-tooltip-cancel-btn').onclick = () => this.hideGemTooltip();
                document.getElementById('gem-tooltip-backdrop').onclick = (e) => {
                    if(e.target.id === 'gem-tooltip-backdrop') this.hideGemTooltip();
                };
            },
            
            hideGemTooltip() {
                document.getElementById('gem-tooltip-backdrop').style.display = 'none';
                document.getElementById('gem-tooltip-content').style.display = 'none';
            },

            handleSocketItemClick(instanceId) {
                if (!state.ui.selectedGemForSocketing) {
                    showToast("Select a gem from your pouch first.", true);
                    return;
                }
                const item = state.player.inventory.find(i => i.instanceId === instanceId);
                const base = GDD.ITEMS.baseItemTemplates.find(b => b.id === item.baseItemId);
                if (item.socketedGems.length >= base.sockets) {
                    showToast("This item has no empty sockets.", true);
                    return;
                }
                this.showSocketConfirmModal(instanceId);
            },

            showSocketConfirmModal(instanceId) {
                const item = state.player.inventory.find(i => i.instanceId === instanceId);
                const baseItem = GDD.ITEMS.baseItemTemplates.find(b => b.id === item.baseItemId);
                const gemInfo = state.ui.selectedGemForSocketing;
                const gem = GDD.GEMS[gemInfo.id];
                const modalContent = document.getElementById('socket-confirm-content');

                modalContent.innerHTML = `
                    <h3 class="font-orbitron text-lg text-center mb-4">Confirm Infusion</h3>
                    <div class="flex items-center justify-around">
                        <div class="text-center">
                            <div class="gem-item gem-type-${gem.type} !w-20 !h-20 mx-auto !border-2">
                                <img src="${gem.imageUrl}" class="w-16 h-16">
                            </div>
                            <p class="text-sm mt-1">${gem.name} G${gemInfo.grade}</p>
                        </div>
                        <i class="gg-arrow-right-o text-2xl text-gray-400"></i>
                        <div class="text-center">
                            <div class="inventory-slot !w-20 !h-20 !p-0 !border-0 mx-auto">
                                <img src="${baseItem.imageUrl}" class="!p-2">
                            </div>
                            <p class="text-sm mt-1">${baseItem.name} T${item.tier}</p>
                        </div>
                    </div>
                    <div class="flex gap-2 mt-6">
                        <button id="socket-confirm-btn" class="modal-button confirm">Confirm</button>
                        <button id="socket-cancel-btn" class="modal-button">Cancel</button>
                    </div>`;

                document.getElementById('socket-confirm-backdrop').style.display = 'flex';
                modalContent.style.display = 'block';

                modalContent.querySelector('#socket-confirm-btn').onclick = () => this.socketGem(instanceId);
                modalContent.querySelector('#socket-cancel-btn').onclick = () => this.hideSocketConfirmModal();
                document.getElementById('socket-confirm-backdrop').onclick = (e) => {
                    if(e.target.id === 'socket-confirm-backdrop') this.hideSocketConfirmModal();
                };
            },

            hideSocketConfirmModal() {
                document.getElementById('socket-confirm-backdrop').style.display = 'none';
                document.getElementById('socket-confirm-content').style.display = 'none';
            },

            socketGem(instanceId) {
                const item = state.player.inventory.find(i => i.instanceId === instanceId);
                const gemToSocket = state.ui.selectedGemForSocketing;
                const gemIndexInPouch = state.player.gems.findIndex(g => g.id === gemToSocket.id && g.grade === gemToSocket.grade);

                if (gemIndexInPouch === -1) {
                    showToast("Error: Selected gem not found.", true); return;
                }

                state.player.gems.splice(gemIndexInPouch, 1);
                item.socketedGems.push(gemToSocket);
                
                state.ui.selectedGemForSocketing = null;
                showToast("Item infused successfully!", false);
                this.hideSocketConfirmModal();
                this.renderAll();
                ProfileManager.calculateAllStats();
                DataManager.updatePlayer({inventory: state.player.inventory, gems: state.player.gems});
            },

            showUnsocketChoiceModal(instanceId) {
                const item = state.player.inventory.find(i => i.instanceId === instanceId);
                const base = GDD.ITEMS.baseItemTemplates.find(b => b.id === item.baseItemId);
                const modalContent = document.getElementById('unsocket-choice-modal-content');
                const gemCount = item.socketedGems.length;
                let glowClass = gemCount > 0 ? (gemCount === base.sockets ? 'glow-full' : 'glow-partial') : '';
                
                modalContent.innerHTML = `
                    <div class="focused-item-container text-center">
                        <div class="inventory-slot mx-auto !w-24 !h-24 !p-0 !border-0">
                            <div class="item-glow-container ${glowClass}"></div>
                            <img src="${base.imageUrl}" class="!p-2" onerror="this.onerror=null;this.src='https://placehold.co/96x96/1f2937/ffffff?text=ERR';">
                        </div>
                        <div class="focused-item-details mt-2"><div class="font-orbitron text-lg">${base.name}</div></div>
                        <p class="text-sm text-gray-400 my-4">Choose an action for the ${gemCount} socketed gem(s).</p>
                        <div class="flex flex-col gap-3">
                            <button id="unsocket-btn" class="modal-button">Unsocket All <span style="color:var(--gold-color)">(${GDD.UNSOCKET_COST} G)</span></button>
                            <button id="destroy-gems-btn" class="modal-button destroy">Destroy All (Free)</button>
                        </div>
                    </div>`;

                document.getElementById('unsocket-choice-modal-backdrop').style.display = 'flex';
                modalContent.style.display = 'block';

                modalContent.querySelector('#unsocket-btn').onclick = () => this.unsocketItem(instanceId);
                modalContent.querySelector('#destroy-gems-btn').onclick = () => this.destroyGems(instanceId);
                document.getElementById('unsocket-choice-modal-backdrop').onclick = (e) => {
                    if(e.target.id === 'unsocket-choice-modal-backdrop') this.hideUnsocketChoiceModal();
                };
            },

            hideUnsocketChoiceModal() {
                document.getElementById('unsocket-choice-modal-backdrop').style.display = 'none';
                document.getElementById('unsocket-choice-modal-content').style.display = 'none';
            },

            unsocketItem(instanceId) {
                if (state.player.gold < GDD.UNSOCKET_COST) {
                    showToast(`Not enough gold. Cost: ${GDD.UNSOCKET_COST}`, true); return;
                }
                state.player.gold -= GDD.UNSOCKET_COST;
                const item = state.player.inventory.find(i => i.instanceId === instanceId);
                const removedGems = item.socketedGems.filter(Boolean);
                state.player.gems.push(...removedGems);
                item.socketedGems = [];
                showToast(`Gems unsocketed for ${GDD.UNSOCKET_COST} gold.`, false);
                this.hideUnsocketChoiceModal();
                this.renderAll();
                ProfileManager.calculateAllStats();
                ProfileManager.updateAllProfileUI();
                DataManager.updatePlayer({inventory: state.player.inventory, gems: state.player.gems, gold: state.player.gold});
            },

            destroyGems(instanceId) {
                const item = state.player.inventory.find(i => i.instanceId === instanceId);
                item.socketedGems = [];
                showToast("Gems destroyed.", false);
                this.hideUnsocketChoiceModal();
                this.renderAll();
                ProfileManager.calculateAllStats();
                DataManager.updatePlayer({inventory: state.player.inventory});
            }
        };

        const UIManager = {
            updatePlayerStatusUI() {
                if (!state.player) return;
                const p = state.player;

                const archetypeAbbr = {
                    'True Fighter': 'FTR',
                    'True Caster': 'CST',
                    'Hybrid': 'HYB'
                }[p.archetype] || 'N/A';
                
                const cciParts = p.cci.split('/');
                const specialization = cciParts[0] === cciParts[1] ? cciParts[0] : p.cci;
                const aspecValue = `${archetypeAbbr}-${specialization}`;

                ui.playerNameLevelValue.textContent = `${p.name} Lvl: ${p.level}`;
                ui.playerRaceValue.textContent = p.race;
                ui.playerAspecValue.textContent = aspecValue;
                ui.zoneNameValue.textContent = state.zone.name;
                ui.playerCoordsValue.textContent = `(${p.pos.x},${p.pos.y})`;
            },
            flashStatUpdate(attr) {
                const statValueEl = document.querySelector(`[data-stat-value="${attr}"]`);
                const unspentPointsEl = document.getElementById('unspent-points-value');
                if (statValueEl) {
                    statValueEl.classList.add('flash-update');
                    setTimeout(() => statValueEl.classList.remove('flash-update'), 500);
                }
                if (unspentPointsEl) {
                    unspentPointsEl.classList.add('flash-update');
                    setTimeout(() => unspentPointsEl.classList.remove('flash-update'), 500);
                }
            }
        };

        const GameManager = {
            isInitialized: false,
            init() {
                if (this.isInitialized) return;
                this.isInitialized = true;
                ui.gameHudScreen.style.display = 'block'; // Use style instead of class for initial show
                ProfileManager.calculateAllStats();
                ProfileManager.updateAllProfileUI();
                WorldMapManager.init();
                initControls();
                this.setupEventListeners();
                this.switchTab('equipment');
                LayoutManager.init();
                ChatManager.init(); // Initialize the chat system
                console.log("Game Initialized. Player loaded:", state.player);
            },
            setupEventListeners() {
                ui.mainTabsContainer.addEventListener('click', (e) => {
                    if (state.ui.isLayoutEditMode) {
                        e.preventDefault();
                        e.stopPropagation();
                        return;
                    }
                    if (e.target.classList.contains('main-tab-button')) {
                        this.switchTab(e.target.dataset.tab);
                    }
                });
                ui.focusModeBtn.addEventListener('click', () => {
                    state.ui.isFocused = !state.ui.isFocused;
                    ui.mainContent.classList.toggle('focused', state.ui.isFocused);
                });
                ui.toggleControlsBtn.addEventListener('click', () => {
                    ui.footerSection.classList.toggle('controls-hidden');
                });
                ui.layoutEditBtn.addEventListener('click', () => {
                    LayoutManager.toggleEditMode();
                });
            },
            switchTab(tabName) {
                document.querySelectorAll('#main-tabs-container .main-tab-button, #main-tab-content .main-tab-panel').forEach(el => el.classList.remove('active'));
                const tabButton = document.querySelector(`.main-tab-button[data-tab="${tabName}"]`);
                const tabPanel = document.getElementById(`tab-content-${tabName}`);
                if (tabButton) tabButton.classList.add('active');
                if (tabPanel) tabPanel.classList.add('active');
                switch(tabName) {
                    case 'combat': CombatManager.init(); break;
                    case 'stats': StatsManager.init(); break;
                    case 'inventory': InventoryManager.init(); break;
                    case 'equipment': EquipmentManager.init(); break;
                    case 'infusion': InfusionManager.init(); break;
                    case 'settings': SettingsManager.init(); break;
                }
            }
        };
        
        const LayoutManager = {
            selectedItem: null,
            initialPinchDistance: 0,
            resizingElement: null,

            init() {
                this.loadLayout();
                this.addEventListeners();
            },
            toggleEditMode() {
                state.ui.isLayoutEditMode = !state.ui.isLayoutEditMode;
                document.getElementById('layout-container').classList.toggle('layout-edit-mode', state.ui.isLayoutEditMode);
                if (!state.ui.isLayoutEditMode) {
                    if (this.selectedItem) {
                        this.selectedItem.classList.remove('layout-selected');
                        this.selectedItem = null;
                    }
                    this.saveLayout();
                    showToast('Layout Saved!');
                } else {
                    showToast('Layout Edit: Tap to select, tap again to swap.');
                }
            },
            addEventListeners() {
                const container = document.getElementById('layout-container');
                container.addEventListener('click', e => this.handleTap(e));
                container.addEventListener('touchstart', e => this.handleTouchStart(e), { passive: false });
                container.addEventListener('touchmove', e => this.handleTouchMove(e), { passive: false });
                container.addEventListener('touchend', e => this.handleTouchEnd(e));
            },
            handleTap(e) {
                if (!state.ui.isLayoutEditMode) return;
                
                const tappedTab = e.target.closest('.tappable-tab');
                if (tappedTab) {
                    e.preventDefault(); e.stopPropagation();
                    this.processSelection(tappedTab, 'tab');
                    return;
                }
                
                const tappedSection = e.target.closest('.tappable-section');
                if (tappedSection) {
                    this.processSelection(tappedSection, 'section');
                }
            },
            processSelection(element, type) {
                if (!this.selectedItem) {
                    this.selectedItem = element;
                    element.classList.add('layout-selected');
                } else {
                    if (this.selectedItem === element) {
                        element.classList.remove('layout-selected');
                        this.selectedItem = null;
                    } else if (this.selectedItem.classList.contains(`tappable-${type}`) && element.classList.contains(`tappable-${type}`)) {
                        const parent = element.parentNode;
                        const selectedNext = this.selectedItem.nextSibling;
                        parent.insertBefore(this.selectedItem, element);
                        parent.insertBefore(element, selectedNext);
                        this.selectedItem.classList.remove('layout-selected');
                        this.selectedItem = null;
                    } else {
                        this.selectedItem.classList.remove('layout-selected');
                        this.selectedItem = element;
                        element.classList.add('layout-selected');
                    }
                }
            },
            handleTouchStart(e) {
                if (!state.ui.isLayoutEditMode || e.touches.length !== 2) return;
                this.resizingElement = e.target.closest('.tappable-section');
                if (!this.resizingElement) return;
                e.preventDefault();
                this.initialPinchDistance = this.getPinchDistance(e.touches);
                this.resizingElement.style.transition = 'none'; // Disable transition for smooth resizing
            },
            handleTouchMove(e) {
                if (!state.ui.isLayoutEditMode || e.touches.length !== 2 || !this.resizingElement) return;
                e.preventDefault();
                const newPinchDistance = this.getPinchDistance(e.touches);
                const scale = newPinchDistance / this.initialPinchDistance;
                
                const currentHeight = this.resizingElement.offsetHeight;
                let newHeight = currentHeight * scale;

                // Clamp the height between min and max values
                const minHeight = 80; // 80px minimum
                const maxHeight = ui.layoutContainer.offsetHeight * 0.7; // 70% of total height
                newHeight = Math.max(minHeight, Math.min(newHeight, maxHeight));

                this.resizingElement.style.flexBasis = `${newHeight}px`;
                this.resizingElement.style.flexGrow = '0';
                this.resizingElement.style.flexShrink = '0';

                this.initialPinchDistance = newPinchDistance; // Update for next move event
            },
            handleTouchEnd(e) {
                if (this.resizingElement) {
                    this.resizingElement.style.transition = ''; // Re-enable transitions
                    this.resizingElement = null;
                    this.initialPinchDistance = 0;
                }
            },
            getPinchDistance(touches) {
                const touch1 = touches[0];
                const touch2 = touches[1];
                return Math.hypot(touch1.pageX - touch2.pageX, touch1.pageY - touch2.pageY);
            },
            saveLayout() {
                const layoutData = {
                    sections: [],
                    tabs: [...document.querySelectorAll('.tappable-tab')].map(el => el.dataset.tab)
                };
                document.querySelectorAll('.tappable-section').forEach(el => {
                    layoutData.sections.push({
                        id: el.id,
                        size: el.style.flexBasis || null
                    });
                });
                localStorage.setItem('geminusLayout', JSON.stringify(layoutData));
            },
            loadLayout() {
                const savedLayout = JSON.parse(localStorage.getItem('geminusLayout'));
                if (savedLayout) {
                    const sectionContainer = document.getElementById('layout-container');
                    const sectionMap = new Map();
                    [...sectionContainer.children].forEach(child => sectionMap.set(child.id, child));
                    
                    savedLayout.sections.forEach(sectionData => {
                        const el = sectionMap.get(sectionData.id);
                        if(el) {
                            sectionContainer.appendChild(el);
                            if (sectionData.size) {
                                el.style.flexBasis = sectionData.size;
                                el.style.flexGrow = '0';
                                el.style.flexShrink = '0';
                            }
                        }
                    });

                    const tabContainer = document.getElementById('main-tabs-container');
                    savedLayout.tabs.forEach(tab => {
                        const el = tabContainer.querySelector(`[data-tab="${tab}"]`);
                        if(el) tabContainer.appendChild(el);
                    });
                }
            }
        };

        // --- Main Initialization ---
        function main() {
            SettingsManager.loadTheme();
            DataManager.init(); // This now starts the game or character creation
        }

        document.addEventListener('DOMContentLoaded', main);
    </script>
</body>
</html>



